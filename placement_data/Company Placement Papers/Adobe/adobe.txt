Exercise 2:

Consider the following problem. 

INPUT: A sequence S of natural numbers of length n, such that n>0 (accessed by S[1], S[2], ..., S[n]). 

OUTPUT: The smallest and the largest element of S. 




Exercise 3 (hand-in, either individually or in pairs):

Consider the following problem. 

INPUT: A sequence S of natural numbers of length n, such that n>0 (accessed by S[1], S[2], ..., S[n]). 

OUTPUT: The second smallest element of S. 

•	Describe a precise algorithm to solve this problem. 
•	What is the number of comparisons of your algorithm in the worst case? 
•	Does this number depend on the input sequence S? If not modify (improve) your algorithm such that it does. 
•	Try your algorithm on some examples (you do not have to write down this part) and for all natural numbers n find a sequence S such that the algorithm performs the largest number of comparisons on this sequence (write down the sequence and the number of comparisons). 

Exercise 4:

Consider the following problem. 

INPUT: Let x and y be words over an alphabet of capital Roman letters {A,B,C, ..., Z} of length n and m, respectively such that n>m>0. Let us call x text and y pattern. 

OUTPUT: A number of occurrences of the pattern y in the text x. 

•	Describe a precise algorithm to solve this problem. 
•	What is the number of comparisons of your algorithm in the worst case? (I.e. given a text x of length n and a pattern y of length m, what is the maximum number of comparisons among all possible input words x and y of the length n and m, respectively?) 
•	For every n and m describe two words x and y of the given length such that your algorithm run on these words performs the largest number of comparisons. 
To access the i'th letter of the word x and y use the syntax x[i] and y[i]. For example if x=ALGORITHM then n=9, x[1]=A, x[3]=G and x[n]=M.

Exercise 1: 

Consider the following algorithm for computing Fibonacci numbers:

fib(n)
= 
table[0] := 0
table[1] := 1
for i:=2 to n do table[i]:= table[i-1]+table[i-2] endfor 
return table[n] 

We have seen that fib(n) has time complexity O(n). 
•	How would you measure the space requirements of the algorithm? What is the space complexity of fib(n)? 
•	Improve the algorithm such that it has O(1) space complexity while preserving O(n) time complexity. 


Exercise 2: 

Design "divide and conquer" algorithm for finding the largest element of a given array A[a..b]. State appropriate pre- and post-conditions.

Exercise 1: 

In this exercise you are asked to implement the operation merge from the D&C sorting algorithm explained at the lecture. 

Let A[1..n], B[1..m] and C[1..(n+m)] be arrays such that n,m>0. 
•	Write an algorithm merge(A,B) which will return an array of size n+m and satisfy the following conditions. Try to achieve an optimal time complexity. 

--pre: A and B are non-decreasing arrays 

C:=merge(A,B); 

--post: C is a non-decreasing array and it is a permutation of the elements from A and B 
•	Run your algorithm on the following instance of the problem: A = [3,4,7] and B =[1,4,8] (i.e. A[1]=3, A[2]=4, A[3]=7, B[1]=1, B[2]=4, B[3]=8). 
•	What is the worst-case time complexity of your algorithm (use the big-O notation and justify your answer)? 

Exercise 6: 

Write a function member(x:ENTRY_TYPE; q:QUEUE):boolean which uses only the queue operations enqueue, front and dequeue and no extra temporary data structures (except for variables). The function should return true if and only if the entry x is present in the queue q. The queue q should not be changed after executing the function member. 

Analyze the worst-case time complexity of your algorithm.

Exercise 2: 

Let t be a binary tree. 
•	Using only the operations of the ADT binary tree write a function no_leaves(x:ENTRY_TYPE):int which returns the number of leaves in the subtree of t rooted by the node x. The tree t should not be modified. 
•	What is the worst case complexity of the call no_leaves(t.root) where the size of the input (number of nodes in t) is denoted by |t|? 
Exercise 3: 

Assume that we have two nonempty sets of elements of the same size: s1={a1, a2, ..., an} and s2={b1, b2, ..., bn}. The sets are stored as sequences in arrays A[1..n] and B[1..n] such that A[i]=ai and B[i]=bi for all i=1 to n. 
•	Design an efficient algorithm to test whether the two sets are equal (the algorithm recieves the arrays A and B as input). Hint: after the execution of the algorithm the arrays can be modified. 
•	Analyze the worst-case time complexity of your algorithm. 

Exercise 2: 
•	Write an algorithm reachable_nodes(g:DIGRAPH, v:VERTEX_TYPE):int which returns the number of nodes reachable from a given node v. The node v should be included in the counting. (Hint: Use BFS as a procedure in your program.) 
•	Let us consider that every node has a distance field. Modify the BFS algorithm such that after the execution of bfs(g,a) for every vertex v the field v.distance contains the length of the shortest path from the start vertex a to v. 

Exercise 4: 

Rewrite the algorithm dfs(g:DIGRAPH,a:VERTEX_TYPE) such that instead of recursion it uses a stack to remember which nodes have to be yet investigated.


Some questions 5/17/2006 5:59 AM
how to find common elements from two link list of size 'n' and 'm' in O(n+m) time complexity.
Assume they are NOT sorted..

how to find common ancestor of two given nodes in a binary tree(not Binary Search Tree)
head node is given for that tree.. 



Write a function that returns a node in a tree given two parameters: 
pointer to the root node and the inorder traversal number of the node we want to return.
 The only information stored in the tree is the number of children for each node


given any number say 12, find the next multiple of 8 eg 16 using bit-wise manipulations


how do identify a no is multiple of 7 using bitwise operation in C

given a number n, How can we check whether n 
is multiple of 3 or not, without using any mathemetical operator



using bit manipulation, find next multiple of 8 for a given number

int nextMultipleOfEight(int num) 
{
i = i rightShift 3;
i++;
i=i leftShift 3;
printf("%d\n",i);
}

Maximum Sub Array Sum 
/***
Input Array has both +ve and -ve ints.
Find the sub array with maximum sum.

Solution:
Run Time : O(n)
Assumes that whenever thisSum is less than 0 then we can get a better sum from the index following the current one.
***/
int maxSubSum3( int [ ] a )
{
int maxSum = 0;
int thisSum = 0;
int i=0;
int j=0;

while (j lessThan a.length)
{
thisSum =thisSum + a[ j ];

if( thisSum greaterThan maxSum )
{
maxSum = thisSum;
seqStart = i;
seqEnd = j;
}
else if( thisSum lessThan 0 )
{
i = j + 1;
thisSum = 0;
}
j=j+1;
}

return maxSum;
} 
posted by Ghotter at 6:53 AM | 0 comments   
Reverse Stack 
/****
Reverse a stack with recursion...u have only pop, push, size,isEmpty functions
****/
void recursive(Stack s)
{
if(s.isEmpty == true)
return ;
elem temp = s.pop();
recursive(s);
recur_push(temp, s);
return;
}
recur_push(elem t, stack s)
{
if(s.isEmpty == null)
{
s.push(t); 
return;
}
temp1= s.pop()
recur_push(t,s);
s.push(temp1);
} 
posted by Ghotter at 5:52 AM | 0 comments   
Wednesday, July 26, 2006
Merge with a twist!! 

/***
Given a array of size M+N in which first M numbers are sorted and last N spaces are vacant. Another array of size N which is sorted. Now merge these two arrays without using any extra space so that the array of M+N size is sorted. Optimize it to hav complexity M+N.
***/

#include
#define M 10
#define N 5
void printArr(int *arr1,int *arr2)
{
int i,j;
printf("\n");
printf("Arr1 Elements\n");
for(i=0;i lessThan M+N;i++)
{
printf("%3d",arr1[i]);
}
printf("\n");
printf("Arr2 Elements\n");
for(i=0;i lessThan N;i++)
{
printf("%3d",arr2[i]);
}
printf("\n");
}
main()
{
int arr1[M+N] = {0};
int arr2[N] = {0};
int i = 0, j =0,temp=0,k=0;
printf("Arr1 Elements\n");

for(i=0;i lessThan M;i++)
{
printf("arr1[%d] = ",i);
scanf(" %d",&arr1[i+N]);
}
printf("Arr2 Elements\n");
for(i=0;i lessThan N;i++)
{
printf("arr2[%d] = ",i);
scanf(" %d",&arr2[i]);
}
printArr(arr1,arr2);
j = 0;
i = N;
k = 0;
while(i lessThan M+N && j lessThan N)
{
if(arr1[i] lessThan arr2[j])
{
arr1[k]=arr1[i];
k++;
i++;
}
else if(arr1[i] greaterThan arr2[j])
{
arr1[k] = arr2[j];
k++;
j++;
}
else
{
arr1[k] = arr2[j];
k++;
j++;
arr1[k] = arr1[i];
k++;
i++;
}
}
while(i lessThan M+N && k lessThan M+N)
{
arr1[k]=arr1[i];
k++;
i++;
}
while(j lessThan N && k lessThan M+N)
{
arr1[k]=arr2[j];
k++;
j++;
}
printArr(arr1,arr2);
} 
posted by Ghotter at 9:39 AM | 0 comments   
Little / Big Endian 
/***
A program to find if a machine is big or little endian.
***/
#include
main()
{
int i = 1;
char *p= (char *)&i;

if(*p == 1)
printf("Little");
else
printf("Big");
printf(" Endian\n");
} 
posted by Ghotter at 5:21 AM | 0 comments   
Monday, July 24, 2006
Rotate Array 
/***
Rotate the array about an index k. 
So if the input was 0 1 2 3 4 5 6
rotating the array about index = 2the o/p would be
3 4 5 6 0 1 2
***/
First, reverse the order of the elements in the whole list:
{xn, xn-1, ..., x1}

Then reverse the sublist containing the last k-1 elements, and then also the sublist containing the other n-k+1 elements:

{xk, xk+1, ..., xn, x1, ..., xk-1}

To illustrate rotating a list of n=5 elements so that k=4 is first:

1 2 3 4 5
reverse list:
5 4 3 2 1
break into sublists and reverse:
5 4 3 2 1
4 5 1 2 3

Each reversal is clearly O(n) and the swapping requires some small constant amount of storage. 
posted by Ghotter at 11:56 PM | 0 comments   
Array flip 
Write a function that will flip the n*n array about its non major diagonal.
Example 3 5 7 makes the non major diagonal in the following manner.
1 2 3 --- 9 6 3 
4 5 6 --- 8 5 2
7 8 9 --- 7 4 1

#define N 10
main()
{
int arr[N][N] = {0};
int i=0,j=0,k=1,temp=0;
printf("\n");
initializeArray(arr,N);
for(i = 0; i lessThan N ; i++)
{
for(j = 0 ; j lessThan N-i-1; j++)
{
temp = arr[i][j];
arr[i][j] = arr[N-1-j][N-1-i];
arr[N-1-j][N-1-i] = temp;
}
}
printf("\n");
printArray(arr,N);
} 
posted by Ghotter at 11:27 PM | 0 comments   
Tree sum 
/***
Given a tree and a sum, write an algorithm to return TRUE if there is a path from the root node down to a leaf such that adding all values of the nodes along the path equals the given sum.
***/

BOOLEAN rootToLeafSumEqualsInput(NODE *root,int sum)
{
if(root.left == NULL && root.right == NULL)
{
if(root.value == sum)
{
printf root.value;
return TRUE;
}
else
return FALSE;
}
if(root.left != NULL)
{
if(rootToLeafSumEqualsInput(root.left,(sum - root.value)) == TRUE)
{
printf root.value;
return TRUE;
}
}
if(root.right != NULL)
{
if(rootToLeafSumEqualsInput(root.left,(sum - root.value)) == TRUE)
{
printf root.value;
return TRUE;
}
}
} 
posted by Ghotter at 10:45 PM | 0 comments   
Arrays Extra Element 
/***
Given two arrays A and B. Array 'A' contains all the elements of 'B' but
one more element extra.
Find out the extra element......
Restrictions: Dont use any relational ops ( > or > or == etc....), array
elements are not in order ...,
***/
main()
{
int A[]={1,4,2,4,5};
int B[]={1,4,2,4};
int sa=5,sb=4;
int sumA=0;
int sumB=0;
int i=0;

for(i=0;i lessThan sa;i++)
{
sumA+=A[i];
}
for(i=0;i lessThan sb;i++)
{
sumB+=B[i];
}

printf("%d\n",sumA-sumB);
} 
posted by Ghotter at 7:04 AM | 0 comments   
0s to Left 1s to the Right 
Given an array with random 0,1 ,sort 0's to left and 1's to right???
in time complexity O(n)..

main()
{
int i = 0;
int arr[]={1,1,0,1,0,1,0,0,1};
int size = 9;
int oneP=0;
int zeroP=0;
while(oneP lessThan size && zeroP lessThan size)
{
if(arr[zeroP] == 0 )
{
zeroP++;
oneP++;
continue;
}
if(arr[oneP] == 0)
{
arr[zeroP] = 0;
arr[oneP] = 1;
zeroP++;
}
oneP++;
}
for(i=0;i lessThan size;i++)
printf("arr[%d]= %d\n",i,arr[i]);
} 
posted by Ghotter at 3:04 AM | 0 comments   
Friday, July 21, 2006
ZigZag 
Problem Statement 
A sequence of numbers is called a zig-zag sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a zig-zag sequence. 

For example, 1,7,4,9,2,5 is a zig-zag sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, 1,4,7,2,5 and 1,7,4,5,5 are not zig-zag sequences, the first because its first two differences are positive and the second because its last difference is zero. 

Given a sequence of integers, sequence, return the length of the longest subsequence of sequence that is a zig-zag sequence. A subsequence is obtained by deleting some number of elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.

import java.util.Random;
class ZigZag
{
static void print(int[] arr)
{
System.out.println();
for(int i=0;i lessThan arr.length;i++)
{
System.out.print(" "+arr[i]);
}
System.out.println();
}
public static void main(String[] args)
{

int[] arr ={ 70, 55, 13, 2, 99, 2, 80, 80, 80, 80, 100, 19, 7, 5, 5, 5,1000,32,32};
int n=arr.length;
int[] numb = new int[n];
int sign=0;
int i=0;
Random r=new Random();
numb[0]=1;
numb[1]=1;
if(arr[0]!=arr[1])
numb[1]=2;
print(arr);
for(i=2;i lessThan n;i++)
{
sign=arr[i-1]-arr[i-2];
print(numb);
if(sign==0 || arr[i]==arr[i-1]) 
{
numb[i]=numb[i-1];
continue;
}
if(sign lessThan 0 && arr[i]-arr[i-1] greaterThan 0) 
{
numb[i]=numb[i-1]+1;
continue;
}
if(sign greaterThan 0 && arr[i]-arr[i-1] lessThan 0) 
{
numb[i]=numb[i-1]+1;
continue;
}
if(sign lessThan 0 && arr[i]-arr[i-1] greaterThan 0) 
{
numb[i]=numb[i-1];
continue;
}
if(sign lessThan 0 && arr[i]-arr[i-1] lessThan 0) 
{
numb[i]=numb[i-1];
continue;
}

} 
print(numb);
}
} 
posted by Ghotter at 4:05 AM | 0 comments   
Wednesday, July 19, 2006
Group Characters Together in Order 
/**
Input will be a string. We need to o/p a string with the order of characters same as the input but with same characters grouped together.
I/P: abcdacde
O/P: aabccdde

I/P: kapilrajadurga
O/P: kaaaapilrrjdug

I/P: 1232
O/P: 1223
**/
I have found out two methods:
Method 1:
/**
Running Time: O(n*n*n)
Here we take one char see if there are any characters which equal it. If any two characters are equal we shift the array by 1 to the right(from the character till the first match) . and keep the matching element in that blank.
For example:
I/P: abcdead
Iteration 1: a bcded
Iteration 2: aabcded
Iteration 3: aabcded
Iteration 4: aabcded
Iteration 5: aabcd e
Iteration 6: aabcdde
Here Blank places mean that we shifted the array from that point till the first match from that point.

**/
main(int argc,char **argv)
{
int i = 0,j=0,k = 0;
int length = 0;
char *inputPtr;
char input[MAX_ALPHABET_LENGTH]={0};
int temp[MAX_ALPHABET_LENGTH]={0};
if(argc lessThan 2)
{
printf("Enter the input String as command line argument\n");
return;
}
strcpy(input,argv[1]);

inputPtr = input;
length = strlen(argv[1]);
printf("Method 1:\n");
printf("I/P: %s\n",inputPtr);

for(i=0;i lessThan length;i++)
{
for(j = i+1;j lessThan length; j++)
{
if(inputPtr[i] == inputPtr[j])
{
for(k = j; k greaterThan i; k-- )
{
inputPtr[k] = inputPtr[k-1];
}
inputPtr[i+1]=inputPtr[i];
}
}
}
printf("O/P: %s\n",inputPtr);

}
Method 2:
/**
Running Time: O(n) with O(1) constant space.
Here i am making the following assumption
1. The character set is limited to 256 characters.

Here we deploy hashing for this:
We have a bucket for 256 characters.
Step 1: We init the bucket to 0.
Step 2: We traverse through the input String and increment the corresponding bucket.
Step 3: We then traverse through the whole input array and check the order of the characters. So once we have printed the input character bucket[character] times then we make the bucket entry for that character to 0.

Though the last for loop seems to be O(n*n) actually it is O(n) only. 
**/
main(int argc,char **argv)
{
int i = 0,j=0,k = 0;
int length = 0;
char *inputPtr;
char input[MAX_ALPHABET_LENGTH]={0};
int temp[MAX_ALPHABET_LENGTH]={0};
if(argc < 2)
{
printf("Enter the input String as command line argument\n");
return;
}

printf("Method 2:\n");
strcpy(input,argv[1]);
inputPtr = input;
length = strlen(argv[1]);
printf("I/P: %s %d\n",inputPtr,length);
for(i = 0; i lessThan length; i++)
{
temp[inputPtr[i]]++;
}
printf("O/P: ");
for( i = 0; i lessThan length ; i++ )
{
for(k=0; k lessThan temp[inputPtr[i]]; k++)
{
printf("%c",inputPtr[i]);
}
temp[inputPtr[i]]=0;
}
printf("\n");
} 
posted by Ghotter at 7:00 AM | 0 comments   
Saturday, July 15, 2006
Index Same As Element 
Suppose that you are given a sorted sequence of distinct integers{a1,a2,...an} . Give an O(log(n)) algorithm to determine whether there exists an index i such at ai = i . For example, in arr[]={-1,0,3,6,7} since arr[3] == 3 the solution should be three.


Solution
We do a binary search for the array. Compare the index of the curr element(ind) and the current elements(arr[ind]). If the ind is less than arr[ind] then match can be found only in the lower half(since all elements are distict). Similarly if ind is greater than arr[ind] then match can be found in the upper half. If Equal then match is found.

pseudo code

int matchIndToElem(int arr[], int size)
{
low = 0;
upper = size - 1;
mid = (low+upper)/2;
while(low < upper)
{
if( mid == arr[mid])
{
printf("Match Found at index %d",mid);
return mid;
}
else if( mid < arr[mid])
{
low = low;
upper = mid;
mid = (upper + low)/2;
}
else
{
low = mid;
upper = upper;
mid = (upper +low)/2;
}
}
if(arr[low] == low)
{
printf("Match Found at index %d",low);
return low; 
}
return -1;
} 
posted by Ghotter at 3:45 AM | 0 comments   
Friday, July 14, 2006
Median 
/*********************************************
X[1...n] and Y[1....n] are 2 sorted arrays....
give O(log n) algo to find median of the array
formed by merging the 2 arrays
*********************************************/

/***
Take the middle of Arr X call it midX and middle element of
Arr Y call it midY..
***/
int findMedian(Array arrX[]) 
{
lowX=0
lowY=0
highX=arrX.size - 1
highY=arrY.size - 1

midX = (highX - lowX)/2
midY = (highY - lowY)/2
while(lowX != highX || lowY !=highY)
{
if(midX < midY)
{
/** 
median lies in between the upperHalf of arrX and lower half of arrY
lowX=midX
highY=midY
midX = midX + (highX - lowX)/2;
midY = (highY - lowY)/2;
**/
}
else if (midX > midY)
{
/** 
median lies in between the upperHalf of arrX and lower half of arrY
lowY =midY
highX=midX
midY = midY + (highY - lowY)/2;
midX = (highX - lowX)/2;
**/
}
else
{
printf("median %d",arrX[midX]);
return arrX[midX];
}
}
return arrX[midX];/*or return arrY[midY]*/
} 
posted by Ghotter at 7:15 AM | 0 comments   
Rotate one to get Another 
/****************************************
Given a string s1 and a string s2,
write a snippet to say whether s2 is a
rotation of s1?

Solution:
concatenate s1 with s1 and do a search
for s2 in that. If found then s2 is a
rotation of s1.
****************************************/
int isRotation(char *s1,char *s2)
{
strcat(s1,s1);
if((temp = strstr(s1,s2))!= NULL)
{
if(strcmp(s1,temp)!= 0)
{
printf("s2 is a rotation of s1 and vice versa\n");
return 1;
}
}
return 0;
} 
posted by Ghotter at 4:53 AM | 0 comments   



Array[1] 
Given two sorted postive integer arrays A[n] and B[n] (W.L.O.G, let's say they are decreasingly sorted), we define a set S = {(a,b) | a \in A and b \in B}. Obviously there are n^2 elements in S. The value of such a pair is defined as Val(a,b) = a + b. Now we want to get the n pairs from S with largest values. The tricky part is that we need an O(n) algorithm. 

Logic:
Take the two arrays and Take a maximal heap...
Now add into heap the first element (A[0]+B[0])...
Now Remove the maximum from the heap...And Print i...
Now if the removed element was (A[i]+B[j]) then push (A[i+1]+B[j]) and (A[i]+B[j+1])...
Do this until you get n elements...
Answer Contributed by f2001840 
posted by Ghotter at 11:49 PM | 0 comments   
Array[0] 
There is an array of size n storing numbers between 0 to n-3 and 2 of the nums repeated. Find both of them.

Example: 
I/P: 0 1 2 1 2 3
O/P: 1 2

This solution is generic for finding if there are any repeats in the array.

Solution:
for(i=0;i lessThan n; i++)
{
swap(arr[i], arr[arr[i]]);
if(i != arr[i] && arr[arr[i]] EQ arr[i])
print "found %d", arr[i]

}
Question And Answer Contributed by f2001389 
posted by Ghotter at 6:26 AM | 1 comments   
Xor linked list 
How to Maintain a double linked list using a single linked list?

Xor linked lists are a curious use of the bitwise exclusive disjunction (XOR) operation to decrease storage requirements for doubly-linked lists. An ordinary doubly-linked list stores addresses of the previous and next list items in each list node, requiring two address fields:

... A-1 A B C C+1 ...
<– prev <– prev <– prev <–
–>next –> next –> next –>
An Xor linked list compresses the same information into one address field by storing the bitwise XOR of the address for previous and the address for next in one field:

... A-1 A B C C+1 ...
–>A-1 XOR B <–> A XOR C <–> B XOR C+1 <–
When you traverse the list from left to right: supposing you are at B, you can take the address of the previous item, A, and XOR it with the value in the XOR field. You will then have the address for C and you can continue traversing the list. The same pattern applies in the other direction.

To start traversing the list in either direction from some point, you need the address of two consecutive items, not just one. If the addresses of the two consecutive items are reversed, you will end up traversing the list in the opposite direction.

This particular trick is generally discouraged for several reasons:

general-purpose debugging tools cannot follow the XOR chain, making debugging more difficult; 
the price for the decrease in memory usage is an increase in code complexity, making maintenance more expensive; and 
conservative garbage collection schemes do not work with data structures that do not contain literal pointers. 
Also, modern computer systems usually have cheap and plentiful memory, so storage overhead is not normally an issue outside specialised embedded systems. Where it is still desirable to reduce the overhead of a linked list, unrolling provides a more practical approach (as well as other advantages, such as increasing cache performance and speeding random accesses). 
posted by Ghotter at 12:14 AM | 0 comments   
Tuesday, June 27, 2006
Infinite Bit Stream Problems 
All such Problems we cannot store the input strings. For all such questions which require computation on infinite Bit Streams we use a FSM(Finite State Machine). Let us discuss some such problems.

1. Find out remainder when the given bit stream is divided by 2.
Input : 010
Output: 0

Input : 0101
Output : 1

Solution:
Design an FSM in which u have states as remainder. So for 2 we can have only two possible remainders 0 or 1.

Now start with a state 0. Be in this state till u get a 1. If in 1 you get a zero then move to state 0 this looks something like this. The end state will give us the remainder.
 




Similarly we can apply the same logic to find the remainder when the number is divided by 3...(Remainder can be 0,1,2)
 

In General:
If you are finding the remainder of a bit stream when divided by N then...
if you are in state A. then 

CASE 1: Input is 0
nextState = (A * 2 + 0) % N

CASE 2: Input is 1
nextState = (A * 2 + 1) % N


When u reach the end of the i/p you state is the remainder....

Code
/*************************************************************
arr contains the input. arr will contain 0/1....
**************************************************************/
unsigned int findRemainder(int arr[],int len, int divisor)
{
int i=0;
int currState = 0;
while(i lessThan len)
{
currState = (currState * 2 + arr[i]) % divisor;
i++;
}
return currState;
}
/************************************************************************
-numberSystem if 2 then input string contains 0/1...
-numberSystem if 10 then input string contains 0/1/2/3/4/5/6/7/8/9
-arr contains the input. arr will contain [0,9]
*************************************************************************/
unsigned int findRemainder(int arr[],unsigned int numberSystem,int len, int divisor)
{
int i=0;
int currState = 0;
while(i lessThan len)
{
currState = (currState * numberSystem + arr[i]) % divisor;
i++;
}
return currState;
} 
posted by Ghotter at 6:10 AM | 0 comments   
Bubble Sort/Insertion Sort 
Methods of Sorting
1. Bubble Sort
Compare the adjacent elements and set the higher index element to the highest among the two. a[i+1] = max(a[i],a[i+1]). So each pass you are actually putting the highest element at the end of the array.
Sample Code:

for (int i = 0; i < data.Length; i++)
for (int j = 0; j < data.Length - 1; j++)
if (data[j] > data[j + 1])
{
tmp = data[j];
data[j] = data[j + 1];
data[j + 1] = tmp;
}


2. Insertion Sort
In Insertion Sort we try to insert one element by element into the already sorted array. So every time we insert a new element we actually shift the whole array.

for (int i = 0; i <= data.Length; i++) {
int j = i;
while (j > 0 && data[i] < data[j - 1])
j--;
int tmp = data[i];
for (int k = i; k > j; k--)
data[k] = data[k - 1];
data[j] = tmp;
}

About Sorting:
http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=sorting 
posted by Ghotter at 1:22 AM | 0 comments   
Dynamic Programming 
Dynamic Programming:
A DP is an algorithmic technique which is usually based on a recurrent formula and one (or some) starting states. A sub-solution of the problem is constructed from previously found ones. DP solutions have a polynomial complexity which assures a much faster running time than other techniques like backtracking, brute-force etc.

Refer these links for more info:
http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=dynProg
http://en.wikipedia.org/wiki/Dynamic_programming



Example Problem:
Given a list of N coins, their values (V1, V2, ... , VN), and the total sum S. Find the minimum number of coins the sum of which is S (we can use as many coins of one type as we want), or report that it's not possible to select coins in such a way that they sum up to S. 

For a better understanding let's take this example:
Given coins with values 1, 3, and 5.
And the sum S is set to be 11. 

First of all we mark that for state 0 (sum 0) we have found a solution with a minimum number of 0 coins. We then go to sum 1. First, we mark that we haven't yet found a solution for this one (a value of Infinity would be fine). Then we see that only coin 1 is less than or equal to the current sum. Analyzing it, we see that for sum 1-V1= 0 we have a solution with 0 coins. Because we add one coin to this solution, we'll have a solution with 1 coin for sum 1. It's the only solution yet found for this sum. We write (save) it. Then we proceed to the next state - sum 2. We again see that the only coin which is less or equal to this sum is the first coin, having a value of 1. The optimal solution found for sum (2-1) = 1 is coin 1. This coin 1 plus the first coin will sum up to 2, and thus make a sum of 2 with the help of only 2 coins. This is the best and only solution for sum 2. Now we proceed to sum 3. We now have 2 coins which are to be analyzed - first and second one, having values of 1 and 3. Let's see the first one. There exists a solution for sum 2 (3 - 1) and therefore we can construct from it a solution for sum 3 by adding the first coin to it. Because the best solution for sum 2 that we found has 2 coins, the new solution for sum 3 will have 3 coins. Now let's take the second coin with value equal to 3. The sum for which this coin needs to be added to make 3 , is 0. We know that sum 0 is made up of 0 coins. Thus we can make a sum of 3 with only one coin - 3. We see that it's better than the previous found solution for sum 3 , which was composed of 3 coins. We update it and mark it as having only 1 coin. The same we do for sum 4, and get a solution of 2 coins - 1+3. And so on. 










•	Linked Lists 
    
o	How do you reverse a singly linked list? How do you reverse a doubly linked list? Write a C program to do the same. Updated!     
o	Given only a pointer to a node to be deleted in a singly linked list, how do you delete it? Updated!     
o	How do you sort a linked list? Write a C program to sort a linked list. Updated!     
o	How to declare a structure of a linked list?     
o	Write a C program to implement a Generic Linked List.     
o	How do you reverse a linked list without using any C pointers? Updated!     
o	How would you detect a loop in a linked list? Write a C program to detect a loop in a linked list.     
o	How do you find the middle of a linked list? Write a C program to return the middle of a linked list     
o	If you are using C language to implement the heterogeneous linked list, what pointer type will you use?     
o	How to compare two linked lists? Write a C program to compare two linked lists.     
o	How to create a copy of a linked list? Write a C program to create a copy of a linked list.     
o	Write a C program to free the nodes of a linked list Updated!     
o	Can we do a Binary search on a linked list?     
o	Write a C program to return the nth node from the end of a linked list. New!     
o	How would you find out if one of the pointers in a linked list is corrupted or not? New!     
o	Write a C program to insert nodes into a linked list in a sorted fashion New!     
o	Write a C program to remove duplicates from a sorted linked list New!     
o	How to read a singly linked list backwards? New!     
o	How can I search for data in a linked list? New! 
    
•	Write your own .... 
    
o	Write your own C program to implement the atoi() function Updated!     
o	Implement the memmove() function. What is the difference between the memmove() and memcpy() function? Updated!     
o	Write C code to implement the strstr() (search for a substring) function.     
o	Write your own printf() function in C     
o	Implement the strcpy() function. Updated!     
o	Implement the strcmp(str1, str2) function. Updated!     
o	Implement the substr() function in C.     
o	Write your own copy() function     
o	Write C programs to implement the toupper() and the isupper() functions Updated!     
o	Write a C program to implement your own strdup() function.     
o	Write a C program to implement the strlen() function     
o	Write your own strcat() function New! 
    
•	Programs 
    
o	Write a C program to swap two variables without using a temporary variable     
o	What is the 8 queens problem? Write a C program to solve it.     
o	Write a C program to print a square matrix helically.     
o	Write a C program to reverse a string Updated!     
o	Write a C program to reverse the words in a sentence in place. Updated!     
o	Write a C program generate permutations.     
o	Write a C program for calculating the factorial of a number     
o	Write a C program to calculate pow(x,n)?     
o	Write a C program which does wildcard pattern matching algorithm     
o	How do you calculate the maximum subarray of a list of numbers?     
o	How to generate fibonacci numbers? How to find out if a given number is a fibonacci number or not? Write C programs to do both.     
o	Solve the Rat In A Maze problem using backtracking.     
o	What Little-Endian and Big-Endian? How can I determine whether a machine's byte order is big-endian or little endian? How can we convert from one to another?     
o	Write C code to solve the Tower of Hanoi problem.     
o	Write C code to return a string from a function Updated!     
o	Write a C program which produces its own source code as its output     
o	Write a C progam to convert from decimal to any base (binary, hex, oct etc...)     
o	Write C code to check if an integer is a power of 2 or not in a single line?     
o	Write a C program to find the GCD of two numbers. Updated!     
o	Finding a duplicated integer problem     
o	Write code to remove duplicates in a sorted array. Updated!     
o	Find the maximum of three integers using the ternary operator.     
o	How do you initialize a pointer inside a function?     
o	Write C code to dynamically allocate one, two and three dimensional arrays (using malloc()) New!     
o	How would you find the size of structure without using sizeof()?     
o	Write a C program to multiply two matrices.     
o	Write a C program to check for palindromes.     
o	Write a C program to convert a decimal number into a binary number.     
o	Write C code to implement the Binary Search algorithm.     
o	Wite code to evaluate a polynomial.     
o	Write code to add two polynomials     
o	Write a program to add two long positive numbers (each represented by linked lists).     
o	How do you compare floating point numbers? Updated!     
o	What's a good way to implement complex numbers in C?     
o	How can I display a percentage-done indication on the screen?     
o	Write a program to check if a given year is a leap year or not?     
o	Is there something we can do in C but not in C++?     
o	How to swap the two nibbles in a byte ?     
o	How to scan a string till we hit a new line using scanf()?     
o	Write pseudocode to compare versions (like 115.10.1 vs 115.11.5).     
o	How do you get the line numbers in C?     
o	How to fast multiply a number by 7?     
o	Write a simple piece of code to split a string at equal intervals     
o	Is there a way to multiply matrices in lesser than o(n^3) time complexity?     
o	How do you find out if a machine is 32 bit or 64 bit?     
o	Write a program to have the output go two places at once (to the screen and to a file also)     
o	Write code to round numbers     
o	How can we sum the digits of a given number in single statement?     
o	Given two strings A and B, how would you find out if the characters in B were a subset of the characters in A?     
o	Write a program to merge two arrays in sorted order, so that if an integer is in both the arrays, it gets added into the final array only once. *     
o	Write a program to check if the stack grows up or down     
o	How to add two numbers without using the plus operator?     
o	How to generate prime numbers? How to generate the next prime after a given prime?     
o	Write a program to print numbers from 1 to 100 without using loops!     
o	Write your own trim() or squeeze() function to remove the spaces from a string. New!     
o	Write your own random number generator function in C.*     
o	Write your own sqrt() function in C* 
    
•	Trees 
    
o	Write a C program to find the depth or height of a tree.     
o	Write a C program to determine the number of elements (or size) in a tree.     
o	Write a C program to delete a tree (i.e, free up its nodes)     
o	Write C code to determine if two trees are identical     
o	Write a C program to find the mininum value in a binary search tree.     
o	Write a C program to compute the maximum depth in a tree?     
o	Write a C program to create a mirror copy of a tree (left nodes become right and right nodes become left)!     
o	Write C code to return a pointer to the nth node of an inorder traversal of a BST. New!     
o	Write C code to implement the preorder(), inorder() and postorder() traversals. Whats their time complexities? Updated!     
o	Write a C program to create a copy of a tree     
o	Write C code to check if a given binary tree is a binary search tree or not?     
o	Write C code to implement level order traversal of a tree. New!     
o	Write a C program to delete a node from a Binary Search Tree?     
o	Write C code to search for a value in a binary search tree (BST).     
o	Write C code to count the number of leaves in a tree     
o	Write C code for iterative preorder, inorder and postorder tree traversals New!     
o	Can you construct a tree using postorder and preorder traversal?     
o	Construct a tree given its inorder and preorder traversal strings. Similarly construct a tree given its inorder and post order traversal strings. Updated!     
o	Find the closest ancestor of two nodes in a tree. New!     
o	Given an expression tree, evaluate the expression and obtain a paranthesized form of the expression.     
o	How do you convert a tree into an array?     
o	What is an AVL tree? Updated!     
o	How many different trees can be constructed using n nodes?     
o	A full N-ary tree has M non-leaf nodes, how many leaf nodes does it have?     
o	Implement Breadth First Search (BFS) and Depth First Search (DFS) Updated!     
o	Write pseudocode to add a new node to a Binary Search Tree (BST) Updated!     
o	What is a threaded binary tree? 
    
•	Bit Fiddling 
    
o	Write a C program to count bits set in an integer? Updated!     
o	What purpose do the bitwise and, or, xor and the shift operators serve?     
o	How to reverse the bits in an interger?     
o	Check if the 20th bit of a 32 bit integer is on or off?     
o	How to reverse the odd bits of an integer?     
o	How would you count the number of bits set in a floating point number?* 
    
•	Sorting Techniques 
    
o	What is heap sort?     
o	What is the difference between Merge Sort and Quick sort?     
o	Give pseudocode for the mergesort algorithm     
o	Implement the bubble sort algorithm. How can it be improved? Write the code for selection sort, quick sort, insertion sort.     
o	How can I sort things that are too large to bring into memory? New! 
    



revstr(char* str)
{
char* a = str;
char* b = str+ (strlen(str) - 1);

while(a < b)
{
*a = *a + *b;
*b = *a - *b;
*a = *a - *b;
++a;
--b;
}
} 


another famous question from Microsoft.

void Reverse(char * S, int N)
{
char * Start=S;
char * End=&S[N-1];

char Temp;

while (Start<End)
{
Temp=*Start;
*Start=*End;
*End=Temp;
Start++;
End--;
}
}

To reverse a string make a call this way:

int main()
{
char Str[100]={"This is a sample string"};

// Reverse entire string
Reverse(Str, strlen(Str));

// To reverse the first word only
Reverse(Str, 4);

// To reverse the fourth word only
Reverse(Str+10, 6);




reverse of link list

node * insert(node * to_insert,node * sorted) {
if (to_insert->value<sorted->value){
to_insert->next=sorted;
return to_insert;
}
node * temp = sorted;
while((temp->next!=null) && (to_insert->value>=temp->next->value)
temp=temp->next;
if (temp->next==null) {
temp->next=to_insert;
return sorted;
}
to_insert->next=temp->next;
temp->next=to_insert;
return sorted;
}


node * sort(node * list) {
node * sorted=list;
list=list->next;
sorted->next=null;
while (list!=null) {
temp=list;
list=list->next;
temp->next=null;
sorted=insert(temp,sorted);
}
return sorted;
}



sorting in descending order
struct node{
int value;
node* NEXT;
}
Assume HEAD pointer denotes the first element in the linked list
Sort()
{
node* first,second,temp;
first=HEAD;
while(first!=null)
{
second=first->NEXT;
while(second!=null)
{
if(first->value<second->value)
{
temp=new node();
temp->value=first->value;
first->value=second->value;
second->value=temp->value;
delete temp;
}
second=second->NEXT;
}
first=first->NEXT;
}
} 



two d array in spiral binding

void print_spiral(int** arr, int size)
{
int i,j,k,middle;

for(i=size-1, j=0; i>0; i--, j++) {

for(k=j; k<i; k++)
printf("%d", arr[j][k]);

for(k=j; k<i; k++)
printf("%d", arr[k][i]);

for(k=i; k>j; k--)
printf("%d", arr[i][k]);

for(k=i; k>j; k--)
printf("%d", arr[k][j]);
}

middle = (n-1)/2;

if (n % 2 == 1)
printf("%d", arr[middle][middle]);

printf("\n");
}




static void spiralRoute()
{
char a[7][7] = {
{'a', 'b', 'c', 'd', 'e', 'f', 'g'},
{'h', 'i', 'j', 'k', 'l', 'm', 'n'},
{'o', 'p', 'q', 'r', 's', 't', 'u'},
{'1', '2', '3', '4', '5', '6', '7'},
{'O', 'P', 'Q', 'R', 'S', 'T', 'U'},
{'H', 'I', 'J', 'K', 'L', 'M', 'N'},
{'A', 'B', 'C', 'D', 'E', 'F', 'G'},
};
char rightoutput[50] = "abcdefgnu7UNGFEDCBAHO1ohijklmt6TMLKJIP2pqrs5SRQ34";
char myoutput[50];

/* DIRECTIONS:
0: towarding right;
1: towarding down;
2: towarding left;
3: towarding up;
*/
int direction = 0;
int up_ = 0, down_ = 6, right_ = 6, left_ = 0;
int i, counter = 0, bOver = 0;

while (!bOver) {
switch (direction)
{
case 0:
if (right_ < left_)
{
bOver = 1;
} else {
for (i = left_; i <= right_; i++)
{
myoutput[counter++] = a[up_][i];
}
up_++;
direction++;
}
break;
case 1:
if (down_ < up_)
{
bOver = 1;
} else {
for (i = up_; i <= down_; i++)
{
myoutput[counter++] = a[i][right_];
}
right_--;
direction++;
}
break;
case 2:
if (right_ < left_)
{
bOver = 1;
} else {
for (i = right_; i >= left_; i--)
{
myoutput[counter++] = a[down_][i];
}
down_--;
direction++;
}
break;

case 3:
if (down_ < up_)
{
bOver = 1;
} else {
for (i = down_; i >= up_; i--)
{
myoutput[counter++] = a[i][left_];
}
left_++;
direction = 0;
}
break;
}
}
myoutput[counter] = '\0';

printf("rightoutput = %s\n", rightoutput);
printf("myoutput %s\n", myoutput);
if (strcmp(rightoutput, myoutput) == 0) {
printf("passed\n");
} else {
printf("not passed\n");
}
}





reverse a integer

int reverse(int i)
{
int rev=0, x=0;
if((i /10) ==0)
return i;
while((i /10) >0)
{
x = i %10;

i= i/10;
rev= (rev *10) +x;
}
rev= rev*10 +i;

return rev;
} 



#include <stdio.h>
main() {
char *x= "acbcd";
char y = 'c';
int len = strlen(x);
int i=0,j=0;
for( i = len-1; i>= 0; i-- ) {
if ( x[i] == y ) {
break;
}
}
printf("%s%c%s%d%s","the # of last occur of ",y," is ",i+1,"\n");
} 



hey guys , was asked to remove duplicate elements from a list...
without hashing and 
in O(n)(so no compariison sort)...

1. Write a program to find the first non-repeating character in a null terminating string.
   Should be O(n) time.

2. Write a program to remove all duplicate elements from a string. Again O(n) time. 

3. Now this is tricky one, hope I explain it well.... 
a. You are given a Double Link List with one pointer of each node pointing to the next node just like in a single link list.
b The second pointer however CAN point to any node in the list and not just the previous node.

Now write a program in O(n) time to duplicate this list. That is, write a program which will 
create a copy of this list. 


4. You are given two things:
a. A binary search tree of integer value nodes (remember integer can have negative values)
b. An integer value X

Write a program that checks if a path exists in the binary search tree that has a total sum of X. By path we mean a complete path - from root of tree to a leaf.  
 
  
   3/17/2006 10:17 AM
5. Write a C++ class definition for a singleton design pattern. 

(Singleton desing pattern means only one instance of the class can exist for the entire program)  




A community of 500 people, each with either brown or blue eyes, lives in a totally enclosed compound with no reflective surfaces (including bodily surfaces.) The law in this community states that no member may ever discuss their own eye color or anyone else's. Everyone will ALWAYS obey the laws and everyone knows that everyone will. Bottom line: no one can figure out their own eye color.

Another law in this community is that if you ever do find out that your eye color is blue, you must kill yourself at midnight that night. This is not a problem, though, since no one can figure that out.

One day, a stranger comes into the compound and announces at noon so that everyone hears him that at least one member of the community has blue eyes. He then leaves the compound.

As result, all fifteen blue eyed members kill themselves.

A) How long after the man's announcement do they die? (not too hard)

B) What new piece of information did the stranger give them? (quite a bit harder)



neha_heights (5/31/2006 4:28:53 AM): an infinite array has been given. in this array there are some zeros initially and after then rest of the elements are 1's . how will u find out the first 1's position in less than O(n) time SOLUTION : Here we assume that the array is in a random access memory. Do a binary search. First look at the elements with indices 1,2,4,8,16,...,etc. When you find the first 1, say between 2^{k-1} and 2^k, do a binary search in between these two. If n is the position of the first 1, then it should take about O(log(n)). 


: Imagine that you have 26 constants, labelled A through Z. Each constant is assigned a value in the following way: A = 1; the rest of the values equal their position in the alphabet (B corresponds to the second position so it equals 2, C = 3, etc.) raised to the power of the preceeding constant value. So, B = 2 ^ (A's value), or B = 2^1 = 2. C = 3^2 = 9. D = 4^9, etc., etc. Find the exact numerical value to the following equation: 
(X - A) * (X - B) * (X - C) * ......... * (X - Z)

1 Motivation problem
[PP, Chapter 7]
Bentley's problem:
² Given an array A[1::n] of integer numbers.
² Find contiguous subarray which has the largest sum.
Example:
31 -41 59 26 -53 58 97 -93 -23 84
^^^^^^^^^^^^^^^
187
Quiz questions:
² What if all numbers are positive?
² What if all numbers are negative?


(Simple) Solution 1: Try all possible subarrays and choose one with the largest sum.
max:=0;
for i:=1 to n do
| for j:=i to n do
| | // compute sum of subarray A[i]..A[j]
| | sum:=0;
| | for k:=i to j do
| | | sum:=sum+A[k];
| | // compare to maximum
| | if sum>max then max:=sum;
Recall: O notation for measuring how running time grows with the size of the output. (cs240)
Informally: Running time is O(f(n)) if it is \proportional" to f(n) for the input of size n.
Time: O(n3)
Q: Can we do better?
Solution 2a: We don't need to recompute sum from scratch every time.
max:=0;
for i:=1 to n do
| sum:=0;
| for j:=i to n do
| | sum:=sum+A[j];
| | // sum is now sum of subarray A[i]..A[j]
| | // compare to maximum
| | if sum>max then max:=sum;


Time: O(n2)
solution 2b: We can compute sum in constant time if we do a little bit of pre-computation.
Let B[i] be the sum of A[1] + : : : + A[i].
Then A[i] + : : : + A[j] = B[j] ¡ B[i ¡ 1].
// precompute B[i]=A[1]+...+A[i]
B[0]:=0;
for i:=1 to n do
| B[i]:=B[i-1]+A[i];
max:=0;
for i:=1 to n do
| for j:=i to n do
| | // compare to maximum
| | if B[j]-B[i-1]>max then
| | | max:=B[j]-B[i-1];


Time: O(n2)
Solution 3 (Divide-and-conquer):
Recall MergeSort: (cs240)
To sort the array:
² Divide an array into two equally-sized parts
² Sort each part separately
² Solution is obtained by \merging" the smaller solutions
The same approach can be used here:
² Divide an array into two equally-sized parts
² Our solution must either be entirely in the left part, or entirely in the right part, or must be going
\through the midle"; therefore:
{ Find the maximum subarray for left part (maxL) and right part (maxR)
{ Find the maximum subarray going \through the middle" (maxM) | this can be done in linear


time O(n)
{ maxfmaxL; maxR; maxMg is the solution.
Examples:
max_M=32+155=182
vvvvvvvvvvvvvvvvv
31 31 -70 59 26 -53 | 58 97 -90 -90 80 80
^^^^^ ^^^^^
max_L=85 max_R=160
max_M=2+155=157
vvvvvvvvvvvvvvvvv
31 31 -70 59 26 -83 | 58 97 -90 -90 80 80
^^^^^ ^^^^^
max_L=85 max_R=160
2
max_M=0+155
vvvvvvv
31 31 -70 59 26 -93 | 58 97 -90 -90 80 80
^^^^^ ^^^^^
max_L=85 max_R=160
Time: O(n log n), as in MergeSort.
(If interested in the details, have a look at PP, chapter 7)


Solution 4:
² maxsoli be the maximum sum subarray of array A[1:: i ].
² tail i be the maximum sum subarray that ends at position i.
What is the relationship between maxsoli and maxsoli¡1?
maxsoli = max½ maxsoli¡1;
tail i;
tail i = max½ tail i¡1 + A[i];
0:
maxsol:=0; tail:=0;
for i:=1 to n do
| // maxsol now corresponds to maxsol[i-1]
| // tail now corresponds to tail[i-1]
| tail:=max(tail+A[i],0);
| maxsol:=max(maxsol,tail);
Time: O(n)
Time comparison
² Solutions implemented in C.
² Some of the values are measured (on Pentium II), some of them are estimated from the other mea-
surements.
² Solution 0 is a ¯ctitious exponential-time solution (just for comparison with others)
² " means under 0.01s


















reverse a stack - inplace
void InsertBefore(CStack *s,int key, int val)
{
int temp;
if (s->IsEmpty())
{
s->Push(val);
return;
}
temp = s->Pop();
if (key == -1)
{
if (s->IsEmpty())
{
s->Push(val);
s->Push(temp);
return;
}
else
{
InsertBefore(s,key,val);
InsertBefore(s,val,temp);
return;
}
}
else
{
if (s->Top() == key || s->IsEmpty())
{
s->Push(val);
s->Push(temp);
return;
}
else
{
InsertBefore(s,key,val);
s->Push(temp);
return;
}
}
}
void ReverseStack(CStack *s)
{
if (s->IsEmpty())
{
return;
}
InsertBefore(s,-1,s->Pop());
} 
 
 
8 queens prob
v,i,j,k,l,s,a[99]; 
main() 
{
   for (scanf("%d",&s);*a-s;v=a[j*=v]-a[i],k=i<s,j+=(v=j<s&&(!k&&!!printf(2+"\n\n%c"-(!l<<!j)," #Q"[l^v?(l^j)&1:2])&&++l||a[i]<s&&v&&v-i+j&&v+i-j))&&!(l%=s),v||(i==j?a[i+=k]=0:++a[i])>=s*k&&++a[--i]);
}  
 
 
common ancestor
mynode *closestAncestor(mynode* root, mynode* p, mynode* q) 
{ 
   mynode *l, *r, *tmp;
   if(root == NULL)
      return(NULL);
   if(root->left==p || root->right==p || root->left==q || root->right==q) 
      return(root);
   else 
   {
      l = closestAncestor(root->left, p, q); 
      r = closestAncestor(root->right, p, q); 
      if(l!=NULL && r!=NULL)
          return(root);
      else
      {
          tmp = (l!=NULL) ? l : r;
          return(tmp);
      } 
   }
 } 
 
 
An operation right-shift on an array of sorted numbers, x, is defined as:
x = {1,2,3,4,5};
right-shift(x, 2) = {4,5,1,2,3}
right-shift(x, 4) = {2,3,4,5,1}

Now the question is,
You are given a right shifted array and you need to find out the number 'n', by which the initial array has been right-shifted.
Assume, 0 <= n < N (where N is the total no. of elements in the array).
O(lgN) solution expected. 
 
int findRotation(int *arr,int start, int end)
{
   int temp,mid;
   if(arr[start]<=arr[end])
      return 0;
   mid = (start+end)/2;
   temp = findRotation(arr,start,mid);
   if(temp!=0)
      return temp;
   return findRotation(arr+mid+1,0,end-mid-1)+mid+1;
} 
 
 
 
aoa1a2.......anb0b1b2........bn   ----->    a0b0a1b1......anbn
zip()
{
int p = 1;
int q;
int k = 0;

int temp1 = arr[p];
int temp2;

while(1)
{
if(k==n-2)
break;
q = GetFinalPos(p);
temp2 = arr[q];
arr[q] = temp1;
temp1 = temp2;
p = q;
k++;
}
}

int GetFinalPos(int p)
{
if (p<n/2)
return 2*p;
else 
return 2*(p-n/2)+1;
} 
 
 
Given a string ex: "aabccdcb". Find all size palindrome of the given string. OUTPUT:- aa aabcc cc cdc .... .... ... The algo should have a time complexity better than O(N^3). 
#include<iostream>
#include<cstring>
#include<string.h>
using namespace std;


void allPalindromes(char *str){
if(!str) return;
string *mystr = new string(str);
int lindex=0, rindex=1;
int tmplindex, tmprindex;
int len = strlen(str);
if(len == 0) return;
if(len == 1){cout<<str<<endl; return;}

//even
while(rindex < len){
if(str[lindex] == str[rindex]){
cout<<mystr->substr(lindex,rindex-lindex+1)<<endl;
tmplindex = lindex; tmprindex = rindex;
while(1){
tmplindex--; tmprindex++;
if((tmplindex<0)||(tmprindex>=len)) break;
if(str[tmplindex] != str[tmprindex]) break;
cout<<mystr->substr(tmplindex,tmprindex-tmplindex+1)<<endl;
}
}
lindex++; rindex++;
}
//odd

int mindex=0;
while(mindex<len){
tmplindex = mindex; tmprindex = mindex;
while(1){
tmplindex--; tmprindex++;
if((tmplindex<0)||(tmprindex>=len)) break;
if(str[tmplindex] != str[tmprindex]) break;
cout<<mystr->substr(tmplindex,tmprindex-tmplindex+1)<<endl;
}
mindex++;
}
}

int main(){
char str[]="abbiabaiazzzzzba";
allPalindromes(str);
} 
 



(1) You are given an array of n numbers. You have to find out that do there exist two such numbers in this array which sum up to a given x. No constrain in memory. Timing constrain: O(n)
(2) Given an array of size n. You have to find which subsequence of this array sums maximum in O(n).
(3) There is a multistory building, in which there are 4 elevators. Find an algo to minimize the wait time.

1) sort an array having elements only 0 and 1 in O(n)time and sorting should terminate immediately after array gets sorted.

2) findout the median of the linkedlist (median is middle element)without counting the no. of elements in the list.(return average of two middle elements in case of even elements in the list)

3)findout the median of two sorted arrays as if this is one sorted array with O(1) space constraint.

4)how will you find out that a given binary tree is binary search tree.

5) given two node pointers in a binary tree . find out the closest common ancestor of the nodes.
