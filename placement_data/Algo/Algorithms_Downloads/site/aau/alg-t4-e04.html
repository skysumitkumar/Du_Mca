<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Algorithms and Data Structures, Aalborg University
  (INF1, Autumn'04)</title>
</head>
<body bgcolor="white">
 <h3>Algorithms and Data Structures (INF1, Autumn'04)</h3>
 <h2>Exercise Set 4</h2>
<br>
<b>Exercise 1:</b> <br><br>

Consider the following algorithm for computing Fibonacci numbers:<br><br>

fib(n)<br> = <br>
table[0] := 0<br>
table[1] := 1<br>
<b>for</b> i:=2 to n <b>do</b> table[i]:= table[i-1]+table[i-2] <b>endfor</b>
<br>
return table[n] <br><br>

We have seen that fib(n) has time complexity O(n).
<ul>
<li> How would you measure the space requirements of the algorithm?
     What is the space complexity of fib(n)?
<li> Improve the algorithm such that it has O(1) space complexity
     while preserving O(n) time complexity.
</ul>
<br>

<b>Exercise 2:</b> <br><br>

Design "divide and conquer" algorithm for finding the largest element
of a given array A[a..b]. State appropriate pre- and post-conditions.

<br><br><br>

<b>Exercise 3:</b> <br><br>

For your algorithm from exercise 2 compute the worst-case complexity
W(n). (Hint: define the worst-case complexity by recurrence equations
and solve them by considering only the points where n=2<sup>k</sup> for
k = 0,1,2, ...).
Approximate W(n) using the big-O notation. <br><br><br>

<b>Exercise 4 (challenging):</b> <br><br>

Exercise 4.6 from Algorithms and Data Structures: Design, Correctness and Analysis by Jeffrey H. Kingston. <br><br>

Indeed, it is possible to find an algorithm with O(n) time complexity!
Try to suggest an algorithm s.t. after every question you ask, one
person can be clearly said not to be a celebrity. 

<br><br><br>


</body>
</html>


