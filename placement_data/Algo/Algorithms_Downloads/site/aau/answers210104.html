<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Algorithms and Data Structures, Aalborg University
  (INF1, Autumn'03)</title>
</head>
<body bgcolor="white">
 <h3>Algorithms and Data Structures (INF1, Autumn'03)</h3>
 <h2>Answers for Exam Questions from 21.1.2004</h2>
<br>

<h3> Question 1</h3>
<ul>
<li> a) True, False, False, True, True
<li> b) No, Yes
<li> c) A,B,D,E,G,H,C,F
<li> d) 5,3,6,8,7,9
<li> e) 3,4,1,2
<li> f) 5 is the root, left child of 5 is 2, right child of 5 is 8;
        right child of 2 is 3; left child of 8 is 6; right child of 6 is 7
<li> g) 0 = nothing, 1 = b, 2 = a, 3 = c, 4 = d
<li> h) e.g. A, E, B, F, D, C, G (more answers were correct)
<li> i) a, c, f, g
</ul>

<h3> Question 2 (sketch)</h3>

The same strategy as for ADT SET can be used here. Only a few
of you noticed that in b) you can use your algorithm from a)
and in c) you can use the algorithms from a) and b). This 
gives very short and elegant solutions.

<h3> Question 3 (sketch)</h3>
The problem was best solved by translating the problem to
a reachability problem in directed graphs. Perhaps the
easiest solution was to model every connection between towns
T and T' by an edge in the graph, however, with the opposite
orientation (from node T' to node T).  <br><br>

Now to check if a town is a metropolitan city we run e.g. bfs
from the city in question and check that all the nodes were
visited. If yes, the town is a metropolitan city. The complexity
is O(n+m). <br><br>

Another solution was without reversing the edges. Then we have to call
the bfs algorithm for every node and check whether the city in
question is visited in all such calls. The worst-case time complexity
for this algorithm is O(n*n+n*m).
</body>
</html>


