<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Algorithms and Data Structures, Aalborg University
  (INF1, Autumn'04)</title>
</head>
<body bgcolor="white">
 <h3>Algorithms and Data Structures (INF1, Autumn'04)</h3>
 <h2>Exercise Set 7</h2>
<br>
<b>Exercise 1 :</b> <br><br>

Write appropriate pre- and post-conditions for the stack operations
<b>push</b>, <b>top</b> and <b>pop</b>.
<br><br><br>

<b>Exercise 2:</b> <br><br>

Implement the stack operations <b>push</b>, <b>top</b> and <b>pop</b> in the
singly-linked list implementation from the lecture (in a stack s
the last entry in the singly-linked list is accessed by <em>last</em>).

<br><br><br>
<b>Exercise 3:</b> <br><br>

Write a procedure <b>reverse(l:LIST)</b> such that it is totally
correct with regard to the following pre- and post-conditions.  <br><br>

--pre: l=< a<sub>1</sub>, a<sub>2</sub> ..., a<sub>n</sub> > <br>
 reverse(l) <br>
--post: l'= < a<sub>n</sub>, ..., a<sub>2</sub>, a<sub>1</sub> > <br><br>

Write an iterative algorithm using stack. What is the worst-case time
complexity of your algorithm? 
<br><br><br>
<b>Exercise 4 (hand-in): </b> <br><br>

Write appropriate pre- and post-conditions for the queue operations
<b>enqueue</b>, <b>front</b> and <b>dequeue</b>.

<br><br><br>
<b>Exercise 5 (hand-in):</b> <br><br>

Implement the queue operations <b>enqueue</b>, <b>front</b> and <b>dequeue</b>
in the circular singly-linked list implementation from the lecture 
(in a queue q the last entry at the back of the queue 
is accessed by <em>last</em>
and the first entry is accessed by <em>last.next_entry</em>). 

<br><br><br>
<b>Exercise 6:</b> <br><br>

Write a function <b>member(x:ENTRY_TYPE; q:QUEUE):boolean</b> which uses
only the queue operations enqueue, front and dequeue and no
extra temporary data structures (except for variables).
The function should return true if and only if the entry x is
present in the queue q. The queue q should not be changed after
executing the function member. <br><br>

Analyze the worst-case time complexity of your algorithm.


<br><br><br>
<b>Exercise 7</b> (voluntary, I will correct your solution if you give me any): <br>
<b>Highly recommended:</b> try to solve this exercise individually, the exam
will be also individual!
<br> <br>

Write an algorithm for a list operation
<b>merge(l<sub>1</sub>:LIST; l<sub>2</sub>:LIST): LIST</b>
which satisfies the following pre- and post-conditions. <br><br>

--pre: l<sub>1</sub>=< a<sub>1</sub>, ..., a<sub>n</sub> > and
       l<sub>2</sub>=< b<sub>1</sub>, ..., b<sub>m</sub> > are
       non-decreasing lists, i.e., a<sub>1</sub>.value <=
       a<sub>2</sub>.value <=  ... <= a<sub>n</sub>.value and
        b<sub>1</sub>.value <=
       b<sub>2</sub>.value <=  ... <= b<sub>m</sub>.value <br><br>
l<sub>3</sub> := merge(l<sub>1</sub>,l<sub>2</sub>) <br><br>
--post: l<sub>3</sub> is a non-decreasing list, it is a permutation 
        of the entries a<sub>1</sub>, ..., a<sub>n</sub>,
        b<sub>1</sub>, ..., b<sub>m</sub> and l'<sub>1</sub>=<>
        and  l'<sub>2</sub>=<> <br><br>
     
What is the worst-case time complexity of your algorithm (use big-O notation)?



</body>
</html>


