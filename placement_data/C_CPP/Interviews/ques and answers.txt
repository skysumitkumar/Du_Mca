Q 1: What is the ``ANSI C Standard?'' 


A: In 1983, the American National Standards Institute (ANSI) commissioned a committee, X3J11, to standardize the C language. After a long, arduous process, including several widespread public reviews, the committee's work was finally ratified as ANS X3.159-1989 on December 14, 1989, and published in the spring of 1990. For the most part, ANSI C standardized existing practice, with a few additions from C++ (most notably function prototypes) and support for multinational character sets (including the controversial trigraph sequences). The ANSI C standard also formalized the C run-time library support routines. 

A year or so later, the Standard was adopted as an international standard, ISO/IEC 9899:1990, and this ISO Standard replaced the earlier X3.159 even within the United States (where it was known as ANSI/ISO 9899-1990 [1992]). As an ISO Standard, it is subject to ongoing revision through the release of Technical Corrigenda and Normative Addenda. 

In 1994, Technical Corrigendum 1 (TC1) amended the Standard in about 40 places, most of them minor corrections or clarifications, and Normative Addendum 1 (NA1) added about 50 pages of new material, mostly specifying new library functions for internationalization. In 1995, TC2 added a few more minor corrections. 

Most recently, a major revision of the Standard, ``C99'', has been completed and adopted. 

Several versions of the Standard, including C99 and the original ANSI Standard, have included a ``Rationale,'' explaining many of its decisions, and discussing a number of subtle points, including several of those covered here. 


Q 2: My ANSI compiler complains about a mismatch when it sees 

	extern int func(float);

	int func(x)
	float x;
	{ ...

A: You have mixed the new-style prototype declaration ``extern int func(float);'' with the old-style definition ``int func(x) float x;''. It is usually possible to mix the two styles (see question 11.4), but not in this case. 

Old C (and ANSI C, in the absence of prototypes, and in variable-length argument lists; see question 15.2) ``widens'' certain arguments when they are passed to functions. floats are promoted to double, and characters and short integers are promoted to int. (For old-style function definitions, the values are automatically converted back to the corresponding narrower types within the body of the called function, if they are declared that way there.) Therefore, the old-style definition above actually says that func takes a double (which will be converted to float inside the function). 

This problem can be fixed either by using new-style syntax consistently in the definition: 

	int func(float x) { ... }


or by changing the new-style prototype declaration to match the old-style definition: 

	extern int func(double);

(In this case, it would be clearest to change the old-style definition to use double as well. [footnote] ) 

It is arguably much safer to avoid ``narrow'' (char, short int, and float) function arguments and return types altogether

Q 3: Why does the declaration 

extern int f(struct x *p);
give me an obscure warning message about ``struct x declared inside parameter list''? 


A: In a quirk of C's normal block scoping rules, a structure declared (or even mentioned) for the first time within a prototype cannot be compatible with other structures declared in the same source file. (The problem is that the structure and the tag go out of scope at the end of the prototype; see question 1.29.) 

To resolve the problem, you should probably rearrange things so that the actual declaration of the structure precedes the function prototype(s) using it. (Usually, both the prototype and the structure declaration will end up in the same header file, so that the one can reference the other.) If you must mention a hitherto-unseen structure in a prototype, precede the prototype with the vacuous-looking declaration 

	struct x;

which places an (incomplete) declaration of struct x at file scope, so that all following declarations involving struct x can at least be sure they're referring to the same struct x. 


Q 4: I don't understand why I can't use const values in initializers and array dimensions, as in 

	const int n = 5;
	int a[n];


A: The const qualifier really means ``read-only''; an object so qualified is a run-time object which cannot (normally) be assigned to. The value of a const-qualified object is therefore not a constant expression in the full sense of the term, and cannot be used for array dimensions, case labels, and the like. (C is unlike C++ in this regard.) When you need a true compile-time constant, use a preprocessor #define (or perhaps an enum). 


Q 5: If you can't modify string literals, why aren't they defined as being arrays of const characters? 

A: One reason is that so very much code contains lines like 

	char *p = "Hello, world!";

which are not necessarily incorrect. These lines would suffer the diagnostic messages, but it's really any later attempt to modify what p points to which would be problems. 

Q 6: What's the difference between const char *p, char const *p, and char * const p? 


A: The first two are interchangeable; they declare a pointer to a constant character (you can't change any pointed-to characters). char * const p declares a constant pointer to a (variable) character (i.e. you can't change the pointer). 

Read these declarations ``inside out'' to understand them; see question 1.21. 


Q 7: Why can't I pass a char ** to a function which expects a const char **? 


A: You can use a pointer-to-T (for any type T) where a pointer-to-const-T is expected. However, the rule (an explicit exception) which permits slight mismatches in qualified pointer types is not applied recursively, but only at the top level. (const char ** is pointer-to-pointer-to-const-char, and the exception therefore does not apply.) 

The reason that you cannot assign a char ** value to a const char ** pointer is somewhat obscure. Given that the const qualifier exists at all, the compiler would like to help you keep your promises not to modify const values. That's why you can assign a char * to a const char *, but not the other way around: it's clearly safe to ``add'' const-ness to a simple pointer, but it would be dangerous to take it away. However, suppose you performed the following more complicated series of assignments: 

	const char c = 'x';		/* 1 */
	char *p1;			/* 2 */
	const char **p2 = &p1;		/* 3 */
	*p2 = &c;			/* 4 */
	*p1 = 'X';			/* 5 */

In line 3, we assign a char ** to a const char **. (The compiler should complain.) In line 4, we assign a const char * to a const char *; this is clearly legal. In line 5, we modify what a char * points to--this is supposed to be legal. However, p1 ends up pointing to c, which is const. This came about in line 4, because *p2 was really p1. This was set up in line 3, which is an assignment of a form that is disallowed, and this is exactly why line 3 is disallowed. 

Assigning a char ** to a const char ** (as in line 3, and in the original question) is not immediately dangerous. But it sets up a situation in which p2's promise--that the ultimately-pointed-to value won't be modified--cannot be kept. 

(C++ has more complicated rules for assigning const-qualified pointers which let you make more kinds of assignments without incurring warnings, but still protect against inadvertent attempts to modify const values. C++ would still not allow assigning a char ** to a const char **, but it would let you get away with assigning a char ** to a const char * const *.) 

In C, if you must assign or pass pointers which have qualifier mismatches at other than the first level of indirection, you must use explicit casts (e.g. (const char **) in this case), although as always, the need for such a cast may indicate a deeper problem which the cast doesn't really fix. 

Q 8: I've got the declarations 

	typedef char *charp;
	const charp p;

Why is p turning out const, instead of the characters pointed to? 


A: typedef substitutions are not purely textual. (This is one of the advantages of typedefs; see question 1.13.) In the declaration 

	const charp p;

p is const for the same reason that const int i declares i as const. The typedef'ed declaration of p does not ``look inside'' the typedef to see that there is a pointer involved. 

Q 9: What's the correct declaration of main()? 


A: There are two valid declarations: 

	int main(void)
	int main(int argc, char **argv)

although they can be written in a variety of ways. The second parameter may be declared char *argv[] (see question 6.4), you can use any names for the two parameters, and you can use old-style syntax: 
	int main()

	int main(argc, argv)
	int argc; char **argv;


Q 10: Can I declare main as void, to shut off these annoying ``main returns no value'' messages? 

A: No. main must be declared as returning an int, and as taking either zero or two arguments, of the appropriate types. If you're calling exit() but still getting warnings, you may have to insert a redundant return statement (or use some kind of ``not reached'' directive, if available). 

Declaring a function as void does not merely shut off or rearrange warnings: it may also result in a different function call/return sequence, incompatible with what the caller (in main's case, the C run-time startup code) expects. That is, if the calling sequences for void- and int-valued functions differ, the startup code is going to be calling main using specifically the int-valued conventions, and if main has been improperly declared as void, it may not work. (See also question 2.18.) 

(Note that this discussion of main pertains only to ``hosted'' implementations; none of it applies to ``freestanding'' implementations, which may not even have main. However, freestanding implementations are comparatively rare, and if you're using one, you probably know it. If you've never heard of the distinction, you're probably using a hosted implementation, and the above rules apply.) 


Q 11: But what about main's third argument, envp? 

A: It's a non-standard (though common) extension. If you really need to access the environment in ways beyond what the standard getenv function provides, though, the global variable environ is probably a better avenue (though it's equally non-standard). 


Q 12: Is exit(status) truly equivalent to returning the same status from main? 


A: Yes and no. The Standard says that a return from the initial call to main is equivalent to calling exit. However, a return from main cannot be expected to work if data local to main might be needed during cleanup; see also question 16.4. A few very old, nonconforming systems may once have had problems with one or the other form. (Finally, the two forms are obviously not equivalent in a recursive call to main.) 


Q 13: I'm trying to use the ANSI ``stringizing'' preprocessing operator `#' to insert the value of a symbolic constant into a message, but it keeps stringizing the macro's name rather than its value. 


A: It turns out that the definition of # says that it's supposed to stringize a macro argument immediately, without further expanding it (if the argument happens to be the name of another macro). You can use something like the following two-step procedure to force a macro to be expanded as well as stringized: 

#define Str(x) #x
#define Xstr(x) Str(x)
#define OP plus
char *opname = Xstr(OP);

This code sets opname to "plus" rather than "OP". (It works because the Xstr() macro expands its argument, and then Str() stringizes it.) [footnote] 

An equivalent circumlocution is necessary with the token-pasting operator ## when the values (rather than the names) of two macros are to be concatenated. 

Note that both # and ## operate only during preprocessor macro expansion. You cannot use them in normal source code, but only in macro definitions. 


Q 14: What does the message ``warning: macro replacement within a string literal'' mean? 


A: Some pre-ANSI compilers/preprocessors interpreted macro definitions like 

	#define TRACE(var, fmt) printf("TRACE: var = fmt\n", var)

such that invocations like 
	TRACE(i, %d);

were expanded as 
	printf("TRACE: i = %d\n", i);

In other words, macro parameters were expanded even inside string literals and character constants. (This interpretation may even have been an accident of early implementations, but it can prove useful for macros like this.) 

Macro expansion is not defined in this way by K&R or by Standard C. (It can be dangerous and confusing: see question 10.22.) When you do want to turn macro arguments into strings, you can use the new # preprocessing operator, along with string literal concatenation (another new ANSI feature): 

	#define TRACE(var, fmt) \
		printf("TRACE: " #var " = " #fmt "\n", var)


Q 15: I'm getting strange syntax errors inside lines I've #ifdeffed out. 


A: Under ANSI C, the text inside a ``turned off'' #if, #ifdef, or #ifndef must still consist of ``valid preprocessing tokens.'' This means that the characters " and ' must each be paired just as in real C code, and the pairs mustn't cross line boundaries. (Note particularly that an apostrophe within a contracted word looks like the beginning of a character constant.) Therefore, natural-language comments and pseudocode should always be written between the ``official'' comment delimiters /* and */. (But see question 20.20, and also 10.25.) 


Q 16: What are #pragmas and what are they good for? 

A: The #pragma directive provides a single, well-defined ``escape hatch'' which can be used for all sorts of (nonportable) implementation-specific controls and extensions: source listing control, structure packing, warning suppression (like lint's old /* NOTREACHED */ comments), etc. 


Q 17: What does ``#pragma once'' mean? I found it in some header files. 

A: It is an extension implemented by some preprocessors to help make header files idempotent; that is, to make sure that their contents are processed exactly once even if they are #included multiple times. It is equivalent to the #ifndef trick mentioned in question 10.7, though less portable. Some people claim that #pragma once can be implemented ``more efficiently'' (of course only compilation efficiency is a factor here), but in fact a preprocessor that is serious about compilation efficiency can arrange for the portable #ifndef trick to be handled just as efficiently. 


Q 18: Is char a[3] = "abc"; legal? What does it mean? 

A: It is legal in ANSI C (and perhaps in a few pre-ANSI systems), though useful only in rare circumstances. It declares an array of size three, initialized with the three characters 'a', 'b', and 'c', without the usual terminating '\0' character. The array is therefore not a true C string and cannot be used with strcpy, printf's %s format, etc. 

Most of the time, you should let the compiler count the initializers when initializing arrays (in the case of the initializer "abc", of course, the computed size will be 4). 


Q 19: Why can't I perform arithmetic on a void * pointer? 

A: The compiler doesn't know the size of the pointed-to objects. (Remember that pointer arithmetic is always in terms of the pointed-to size; see also question 4.4.) Therefore, arithmetic on void *'s is disallowed (though some compilers allow it as an extension). Before performing arithmetic, convert the pointer either to char * or to the pointer type you're trying to manipulate (but see also questions 4.5 and 16.7). 


Q 20: What's the difference between memcpy and memmove? 

A: memmove offers guaranteed behavior if the memory regions pointed to by the source and destination arguments overlap. memcpy makes no such guarantee, and may therefore be more efficiently implementable. When in doubt, it's safer to use memmove. 

It seems simple enough to implement memmove; the overlap guarantee apparently requires only an additional test: 

void *memmove(void *dest, void const *src, size_t n)
{
	register char *dp = dest;
	register char const *sp = src;
	if(dp < sp) {
		while(n-- > 0)
			*dp++ = *sp++;
	} else {
		dp += n;
		sp += n;
		while(n-- > 0)
			*--dp = *--sp;
	}

	return dest;
}

The problem with this code is in that additional test: the comparison (dp < sp) is not quite portable (it compares two pointers which do not necessarily point within the same object) and may not be as cheap as it looks. On some machines (particularly segmented architectures), it may be tricky and significantly less efficient [footnote] to implement. 


Q 21: What should malloc(0) do? Return a null pointer or a pointer to 0 bytes? 

A: The ANSI/ISO Standard says that it may do either; the behavior is implementation-defined (see question 11.33). Portable code must either take care not to call malloc(0), or be prepared for the possibility of a null return. 



Q 22 : Why does the ANSI Standard place limits on the length and case-significance of external identifiers? 

A: The problem is linkers which are under control of neither the ANSI/ISO Standard nor the C compiler developers on the systems which have them. The limitation is only that identifiers be significant in some initial sequence of characters, not that they be restricted to that many characters in total length. (The limitation was to six characters in the original ANSI Standard, but has been relaxed to 31 in C99.) 

Q 23: What was noalias and what ever happened to it? 

A: noalias was another type qualifier, in the same syntactic class as const and volatile, which was intended to assert that an object was not pointed to (``aliased'') by other pointers. The primary application, which is an important one, would have been for the formal parameters of functions designed to perform computations on large arrays. A compiler cannot usually take advantage of vectorization or other parallelization hardware (on supercomputers which have it) unless it can ensure that the source and destination arrays do not overlap. 

The noalias keyword was not backed up by any ``prior art,'' and it was introduced late in the review and approval process. It was surprisingly difficult to define precisely and explain coherently, and sparked widespread, acrimonious debate, including a scathing pan by Dennis Ritchie. It had far-ranging implications, particularly for several standard library interfaces, for which easy fixes were not readily apparent. 

Because of the criticism and the difficulty of defining noalias well, the Committee declined to adopt it, in spite of its superficial attractions. (When writing a standard, features cannot be introduced halfway; their full integration, and all implications, must be understood.) The need for an explicit mechanism to support parallel implementation of non-overlapping operations remains unfilled (although some work is being done on the problem). 


Q 24: What's wrong with this code? 

char c;
while((c = getchar()) != EOF) ...

A: For one thing, the variable to hold getchar's return value must be an int. EOF is an ``out of band'' return value from getchar: it is distinct from all possible char values which getchar can return. (On modern systems, it does not reflect any actual end-of-file character stored in a file; it is a signal that no more characters are available.) getchar's return value must be stored in a variable larger than char so that it can hold all possible char values, and EOF. 

Two failure modes are possible if, as in the fragment above, getchar's return value is assigned to a char. 

If type char is signed, and if EOF is defined (as is usual) as -1, the character with the decimal value 255 ('\377' or '\xff' in C) will be sign-extended and will compare equal to EOF, prematurely terminating the input. [footnote] 
If type char is unsigned, an actual EOF value will be truncated (by having its higher-order bits discarded, probably resulting in 255 or 0xff) and will not be recognized as EOF, resulting in effectively infinite input. 
The bug can go undetected for a long time, however, if chars are signed and if the input is all 7-bit characters. (Whether plain char is signed or unsigned is implementation-defined.) 


Q 25: Why does the simple line-copying loop while(!feof(infp)) { fgets(buf, MAXLINE, infp); fputs(buf, outfp); } copy the last line twice? 

A: In C, end-of-file is only indicated after an input routine has tried to read, and failed. (In other words, C's I/O is not like Pascal's.) Usually, you should just check the return value of the input routine: 

	while(fgets(buf, MAXLINE, infp) != NULL)
		fputs(buf, outfp);

In virtually all cases, there's no need to use feof at all. (feof, or more likely ferror, may be useful after a stdio call has returned EOF or NULL, to distinguish between an end-of-file condition and a read error.) 


Q 26: Why doesn't 

long int n = 123456;
printf("%d\n", n);
work? 

A: Whenever you print long ints you must use the l (lower case letter ``ell'') modifier in the printf format (e.g. %ld). printf can't know the types of the arguments which you've passed to it, so you must let it know by using the correct format specifiers. 


Q 27: Someone told me it was wrong to use %lf with printf. How can printf use %f for type double, if scanf requires %lf? 

A: It's true that printf's %f specifier works with both float and double arguments.[footnote] Due to the ``default argument promotions'' (which apply in variable-length argument lists [footnote] such as printf's, whether or not prototypes are in scope), values of type float are promoted to double, and printf therefore sees only doubles. (printf does accept %Lf, for long double.) See also question 15.2. 

scanf, on the other hand, accepts pointers, and no such promotions apply. Storing into a float (via a pointer) is very different from storing into a double, so scanf distinguishes between %f and %lf. 

Here is a table listing the argument types expected by printf and scanf for the various format specifiers: 

[TABLE GOES HERE] 

(Strictly speaking, %lf is undefined under printf, though many systems probably accept it. To be portable, always use %f.) 


Q 28: What printf format should I use for a typedef like size_t when I don't know whether it's long or some other type? 

A: Use a cast to convert the value to a known, conservatively-sized type, then use the printf format matching that type. For example, to print the size of a type, you might use 

	printf("%lu", (unsigned long)sizeof(thetype));


Q 29: How can I implement a variable field width with printf? That is, instead of something like %8d, I want the width to be specified at run time. 

A: printf("%*d", width, x) will do just what you want. The asterisk in the format specifier indicates that an int value from the argument list will be used for the field width. (Note that in the argument list, the width precedes the value to be printed.) See also question 12.15. 


Q 30: Why doesn't the call scanf("%d", i) work? 

A: The arguments you pass to scanf must always be pointers: for each value converted, scanf ``returns'' it by filling in one of the locations you've passed pointers to. (See also question 20.1.) To fix the fragment above, change it to scanf("%d", &i) . 


Q 31: Why doesn't this code: 

double d;
scanf("%f", &d);
work? 

A: Unlike printf, scanf uses %lf for values of type double, and %f for float. [footnote] %f tells scanf to expect a pointer-to-float, not the pointer-to-double you gave it. Either use %lf, or declare the receiving variable as a float. See also question 12.9. 


Q 32: How can I read data from data files with particular formats? 
How can I read ten floats without having to use a jawbreaker scanf format 
like "%f %f %f %f %f %f %f %f %f %f"? 
How can I read an arbitrary number of fields from a line into an array? 

A: In general, there are three main ways of parsing data lines: 

Use fscanf or sscanf, with an appropriate format string. Despite the limitations mentioned in this section (see question 12.20), the scanf family is quite powerful. Though whitespace-separated fields are always the easiest to deal with, scanf format strings can also be used with more compact, column oriented, FORTRAN-style data. For instance, the line 
	1234ABC5.678

could be read with "%d%3s%f". (See also the last example in question 12.19.) 
Break the line into fields separated by whitespace (or some other delimiter), using strtok or the equivalent (see question 13.6), then deal with each field individually, perhaps with functions like atoi and atof. (Once the line is broken up, the code for handling the fields is much like the traditional code in main() for handling the argv array; see question 20.3.) This method is particularly useful for reading an arbitrary (i.e. not known in advance) number of fields from a line into an array. 
Here is a simple example which copies a line of up to 10 floating-point numbers (separated by whitespace) into an array: 

#define MAXARGS 10

char line[] = "1 2.3 4.5e6 789e10";
char *av[MAXARGS];
int ac, i;
double array[MAXARGS];

ac = makeargv(line, av, MAXARGS);
for(i = 0; i < ac; i++)
	array[i] = atof(av[i]);

(See question 13.6 for the definition of makeargv.) 

Use whatever pointer manipulations and library routines are handy to parse the line in an ad-hoc way. (The ANSI strtol and strtod functions are particularly useful for this style of parsing, because they can return a pointer indicating where they stopped reading.) This is obviously the most general way, but it's also the most difficult and error-prone: the thorniest parts of many C programs are those which use lots of tricky little pointers to pick apart strings. 
When possible, design data files and input formats so that they don't require arcane manipulations, but can instead be parsed with easier techniques such as 1 and 2: dealing with the files will then be much more pleasant all around. 

Q 33: I'm reading a number with scanf and %d, and then a string with gets(): 

	int n;
	char str[80];

	printf("enter a number: ");
	scanf("%d", &n);
	printf("enter a string: ");
	gets(str);
	printf("you typed %d and \"%s\"\n", n, str);

but the compiler seems to be skipping the call to gets()! 

A: If, in response to the above program, you type the two lines 

	42
	a string

scanf will read the 42, but not the newline following it. That newline will remain on the input stream, where it will immediately satisfy gets() (which will therefore seem to read a blank line). The second line, ``a string'', will not be read at all. 

If you had happened to type both the number and the string on the same line: 

	42 a string

the code would have worked more or less as you expected. 

As a general rule, you shouldn't try to interlace calls to scanf with calls to gets() (or any other input routines); scanf's peculiar treatment of newlines almost always leads to trouble. Either use scanf to read everything or nothing. 


Q 34: Why does everyone say not to use scanf? What should I use instead? 

A: scanf has a number of problems--see questions 12.17, 12.18a, and 12.19. Also, its %s format has the same problem that gets() has (see question 12.23)--it's hard to guarantee that the receiving buffer won't overflow. [footnote] 

More generally, scanf is designed for relatively structured, formatted input (its name is in fact derived from ``scan formatted''). If you pay attention, it will tell you whether it succeeded or failed, but it can tell you only approximately where it failed, and not at all how or why. You have very little opportunity to do any error recovery. 

Yet interactive user input is the least structured input there is. A well-designed user interface will allow for the possibility of the user typing just about anything--not just letters or punctuation when digits were expected, but also more or fewer characters than were expected, or no characters at all (i.e. just the RETURN key), or premature EOF, or anything. It's nearly impossible to deal gracefully with all of these potential problems when using scanf; it's far easier to read entire lines (with fgets or the like), then interpret them, either using sscanf or some other techniques. (Functions like strtol, strtok, and atoi are often useful; see also questions 12.16 and 13.6.) If you do use any scanf variant, be sure to check the return value to make sure that the expected number of items were found. Also, if you use %s, be sure to guard against buffer overflow. 

Note, by the way, that criticisms of scanf are not necessarily indictments of fscanf and sscanf. scanf reads from stdin, which is usually an interactive keyboard and is therefore the least constrained, leading to the most problems. When a data file has a known format, on the other hand, it may be appropriate to read it with fscanf. It's perfectly appropriate to parse strings with sscanf (as long as the return value is checked), because it's so easy to regain control, restart the scan, discard the input if it didn't match, etc. 


Q 35: How can I tell how much destination buffer space I'll need for an arbitrary sprintf call? How can I avoid overflowing the destination buffer with sprintf? 

A: When the format string being used with sprintf is known and relatively simple, you can sometimes predict a buffer size in an ad-hoc way. If the format consists of one or two %s's, you can count the fixed characters in the format string yourself (or let sizeof count them for you) and add in the result of calling strlen on the string(s) to be inserted. For example, to compute the buffer size that the call 

	sprintf(buf, "You typed \"%s\"", answer);

would need, you could write: 
	int bufsize = 13 + strlen(answer);
or
	int bufsize = sizeof("You typed \"%s\"") + strlen(answer);

followed by 
	char *buf = malloc(bufsize);
	if(buf != NULL)
		sprintf(buf, "You typed \"%s\"", answer);

You can conservatively estimate the size that %d will expand to with code like: 
#include <limits.h>
char buf[(sizeof(int) * CHAR_BIT + 2) / 3 + 1 + 1];
sprintf(buf, "%d", n);

This code computes the number of characters required for a base-8 representation of a number; a base-10 expansion is guaranteed to take as much room or less. (The +2 takes care of truncation if the size is not a multiple of 3, and the +1+1 leaves room for a leading - and a trailing \0.) An analogous technique could of course be used for long int, and the same buffer can obviously be used with %u, %o, and %x formats as well. 

When the format string is more complicated, or is not even known until run time, predicting the buffer size becomes as difficult as reimplementing sprintf, and correspondingly error-prone (and inadvisable). A last-ditch technique which is sometimes suggested is to use fprintf to print the same text to a temporary file, and then to look at fprintf's return value or the size of the file (but see question 19.12). (Using a temporary file for this application is admittedly clumsy and inelegant,[footnote] but it's the only portable solution besides writing an entire sprintf format interpreter. If your system provides one, you can use a null or ``bit bucket'' device such as /dev/null or NUL instead of a temporary file.) 

If there's any chance that the buffer might not be big enough, you won't want to call sprintf without some guarantee that the buffer will not overflow and overwrite some other part of memory. If the format string is known, you can limit %s expansion by using %.Ns for some N, or %.*s (see also question 12.10). 

To avoid the overflow problem, you can use a length-limited version of sprintf, namely snprintf. It is used like this: 

	snprintf(buf, bufsize, "You typed \"%s\"", answer);

snprintf has been available in several stdio libraries (including GNU and 4.4bsd) for several years. It has finally been standardized in C99. 

As an extra, added bonus, the C99 snprintf provides a way to predict the size required for an arbitrary sprintf call. C99's snprintf returns the number of characters it would have placed in the buffer if there were room, not just how many it did place. Furthermore, it may be called with a null pointer and a buffer size of 0 and a null pointer as the destination buffer. Therefore, the call 

	nch = snprintf(NULL, 0, fmtstring, /* other arguments */ );

computes the number of characters required for the fully-formatted string. With that number (nch) in hand, you can then malloc a big-enough buffer and make a second snprintf call to fill it. 

Yet another option is the (nonstandard) asprintf function, present in various C libraries including bsd's and GNU's, which formats to (and returns a pointer to) a malloc'ed buffer, like this: 

char *buf;
asprintf(&buf, "%d = %s", 42, "forty-two");
/* now buf points to malloc'ed space containing formatted string */


Q 36: What's the deal on sprintf's return value? Is it an int or a char *? 

A: The Standard says that it returns an int (the number of characters written, just like printf and fprintf). Once upon a time, in some C libraries, sprintf returned the char * value of its first argument, pointing to the completed result (i.e. analogous to strcpy's return value). 


Q 37: What's the difference between fgetpos/fsetpos and ftell/fseek? 
What are fgetpos and fsetpos good for? 

A: ftell and fseek use type long int to represent offsets (positions) in a file, and may therefore be limited to offsets which can be represented in a long int. (Type long int is not guaranteed to hold values larger than 2**31-1, limiting the maximum offset to 2 gigabytes). The newer fgetpos and fsetpos functions, on the other hand, use a special typedef, fpos_t, to represent the offsets. The type behind this typedef, if chosen appropriately, can represent arbitrarily large offsets, so fgetpos and fsetpos can be used with arbitrarily huge files. fgetpos and fsetpos also record the state associated with multibyte streams. See also question 1.4. 


Q 38: How can I open files with names like ``file1'', ``file2'', ``file3'', etc., where the numeric part is controlled by a variable? Basically I want ``file%d'', like printf. 

A: You want printf's close cousin sprintf, which ``prints'' to a string: 

	char filename[FILENAME_MAX];
	sprintf(filename, "file%d", i);
	fp = fopen(filename, "r");



Q 39: How can I redirect stdin or stdout to a file from within a program? 

A: Use freopen. If you're calling a function f() which writes to stdout, and you want to send its output to a file, and you don't have the option of rewriting f, you can use a sequence like: 

	freopen(file, "w", stdout);
	f();


Q 40: How can I tell if standard input or output is redirected (i.e. whether ``<'' or ``>'' was used on the invocation command line)? 

A: You can't tell directly, but you can usually look at a few other things to make whatever decision you need to. If you want your program to take input from stdin when not given any input files, you can do so if argv doesn't mention any input files (see question 20.3), or perhaps if you're given a placeholder like ``-'' instead of a filename. If you want to suppress prompts if input is not coming from an interactive terminal, on some systems (e.g. Unix, and usually MS-DOS) you can use isatty(0) or isatty(fileno(stdin)) to make the determination. 


Q 41: How can I arrange to have output go two places at once, e.g. to the screen and to a file? 

A: You can't do this directly, but you could write your own printf variant which printed everything twice. Here is a sample logprintf function which prints to both stdout and a preopened log file: 

#include <stdio.h>
#include <stdarg.h>

extern FILE *logfp;

void logprintf(char *fmt, ...)
{
	va_list argp;
	va_start(argp, fmt);
	vfprintf(stdout, fmt, argp);
	va_end(argp);
	va_start(argp, fmt);
	vfprintf(logfp, fmt, argp);
	va_end(argp);
}

Now, whenever you call logprintf (which you can call with format strings just like printf), it prints both to stdout and to logfp, which you have presumably opened to your desired log file. Another way to arrange this would be 
void f2printf(FILE *fp1, FILE *fp2, char *fmt, ...)
{
	va_list argp;
	va_start(argp, fmt); vfprintf(fp1, fmt, argp); va_end(argp);
	va_start(argp, fmt); vfprintf(fp2, fmt, argp); va_end(argp);
}

where f2printf is just like fprintf except that you give it two file pointers (e.g. stdout and logfp) and it prints to both of them. 

Both of these techniques obviously require you to use explicit calls to logprintf or f2printf. There is no known way in Standard C to arrange implicitly (i.e. via some call analogous to freopen) that one stream, which you print to once with a normal call like fprintf, print to two places at once


Q 42: I want to read and write numbers between files and memory in a byte-at-a-time way, not as formatted characters the way fprintf and fscanf do. How can I do this? 

A: What you're trying to do is usually called ``binary'' I/O. First, make sure that you are calling fopen with the "b" modifier ("rb", "wb", etc.; see question 12.38). Then, use the & and sizeof operators to get a handle on the sequences of bytes you are trying to transfer. Usually, the fread and fwrite functions are what you want to use; see question 2.11 for an example. 

Note, though, that fread and fwrite do not necessarily imply binary I/O. If you've opened a file in binary mode, you can use any I/O calls on it (see for example the examples in question 12.42); if you've opened it in text mode, you can use fread or fwrite if they're convenient. 

Finally, note that binary data files are not very portable; see question 20.5. 


Q 43: What's the difference between text and binary I/O? 

A: In text mode, a file is assumed to consist of lines of printable characters (perhaps including tabs). The routines in the stdio library (getc, putc, and all the rest) translate between the underlying system's end-of-line representation and the single \n used in C programs. C programs which simply read and write text therefore don't have to worry about the underlying system's newline conventions: when a C program writes a '\n', the stdio library writes the appropriate end-of-line indication, and when the stdio library detects an end-of-line while reading, it returns a single '\n' to the calling program. [footnote] 

In binary mode, on the other hand, bytes are read and written between the program and the file without any interpretation. (On MS-DOS systems, binary mode also turns off testing for control-Z as an in-band end-of-file character.) 

Text mode translations also affect the apparent size of a file as it's read. Because the characters read from and written to a file in text mode do not necessarily match the characters stored in the file exactly, the size of the file on disk may not always match the number of characters which can be read from it. Furthermore, for analogous reasons, the fseek and ftell functions do not necessarily deal in pure byte offsets from the beginning of the file. (Strictly speaking, in text mode, the offset values used by fseek and ftell should not be interpreted at all: a value returned by ftell should only be used as a later argument to fseek, and only values returned by ftell should be used as arguments to fseek.) 

In binary mode, fseek and ftell do use pure byte offsets. However, some systems may have to append a number of null bytes at the end of a binary file to pad it out to a full record. 

Q 44: How can I convert numbers to strings (the opposite of atoi)? Is there an itoa function? 

A: Just use sprintf: 

	sprintf(string, "%d", number);

(Don't worry that sprintf may be overkill, potentially wasting run time or code space; it works well in practice.) See also the examples in the answer to question 7.5a, and also questions 8.6 and 12.21. 

You can obviously use sprintf to convert long or floating-point numbers to strings as well (using %ld or %f); in other words, sprintf can also be thought of as the opposite of atol and atof. In addition, you have quite a bit of control over the formatting. (It's for these reasons that C supplies sprintf as a general solution, and not itoa.) 

If you simply must write an itoa function, here are some things to consider: 

There is a sample implementation in K&R. 
You'll have to worry about return buffer allocation; see question 7.5a. 
A naïve implementation usually doesn't handle the most-negative integer (INT_MIN, usually -32,768 or -2,147,483,648) properly. 


Q 45: Why does strncpy not always place a '\0' terminator in the destination string? 

A: strncpy was first designed to handle a now-obsolete data structure, the fixed-length, not-necessarily-\0-terminated ``string.'' [footnote] strncpy is admittedly a bit cumbersome to use in other contexts, since you must often append a '\0' to the destination string by hand. 

You can get around the problem by using strncat instead of strncpy. If the destination string starts out empty (that is, if you do *dest = '\0' first), strncat does what you probably wanted strncpy to do: 

	*dest = '\0';
	strncat(dest, source, n);

This code copies up to n characters, and always appends a \0. 

Another possibility is 

sprintf(dest, "%.*s", n, source)

(though, strictly speaking, this is only guaranteed to work for n <= 509). 

When arbitrary bytes (as opposed to strings) are being copied, memcpy is usually a more appropriate function to use than strncpy. 


Q 46: Does C have anything like the ``substr'' (extract substring) routine present in other languages? 

A: Not as such. (One reason it doesn't is that, as mentioned in question 7.2 and section 8, C has no managed string type.) 

To extract a substring of length LEN starting at index POS in a source string, use something like 

	char dest[LEN+1];
	strncpy(dest, &source[POS], LEN);
	dest[LEN] = '\0';	/* ensure \0 termination */

or, using the trick from question 13.2, 
	char dest[LEN+1] = "";
	strncat(dest, &source[POS], LEN);

or, making use of pointer instead of array notation, 
	strncat(dest, source + POS, LEN);

(The expression source + POS is, by definition, identical to &source[POS] --see also section 6.) 


Q 47: How can I split up a string into whitespace-separated fields? 
How can I duplicate the process by which main() is handed argc and argv? 

A: The only Standard function available for this kind of ``tokenizing'' is strtok, although it can be tricky to use [footnote] and it may not do everything you want it to. (For instance, it does not handle quoting.) Here is a usage example, which simply prints each field as it's extracted: 

#include <stdio.h>
#include <string.h>
char string[] = "this is a test";	/* not char *; see Q 16.6 */
char *p;
for(p = strtok(string, " \t\n"); p != NULL;
			p = strtok(NULL, " \t\n"))
	printf("\"%s\"\n", p);


As an alternative, here is a routine I use for building an argv all at once: 

#include <ctype.h>

int makeargv(char *string, char *argv[], int argvsize)
{
	char *p = string;
	int  i;
	int argc = 0;

	for(i = 0; i < argvsize; i++) {
		/* skip leading whitespace */
		while(isspace(*p))
			p++;

		if(*p != '\0')
			argv[argc++] = p;
		else {
			argv[argc] = 0;
			break;
		}

		/* scan over arg */
		while(*p != '\0' && !isspace(*p))
			p++;
		/* terminate arg: */
		if(*p != '\0' && i < argvsize-1)
			*p++ = '\0';
	}

	return argc;
}


Calling makeargv is straightforward: 

	char *av[10];
	int i, ac = makeargv(string, av, 10);
	for(i = 0; i < ac; i++)
		printf("\"%s\"\n", av[i]);


If you want each separator character to be significant, for instance if you want two tabs in a row to indicate an omitted field, it's probably more straightforward to use strchr: 

#include <stdio.h>
#include <string.h>

char string[] = "this\thas\t\tmissing\tfield";
char *p = string;

while(1) {		/* break in middle */
	char *p2 = strchr(p, '\t');
	if(p2 != NULL)
		*p2 = '\0';
	printf("\"%s\"\n", p);
	if(p2 == NULL)
		break;
	p = p2 + 1;
}


All the code fragments presented here modify the input string, by inserting \0's to terminate each field (meaning that the string must be writable; see question 1.32). If you'll need the original string later, make a copy before breaking it up. 



Q 48 : How can I sort a linked list? 

A: Sometimes it's easier to keep the list in order as you build it (or perhaps to use a tree instead). Algorithms like insertion sort and merge sort lend themselves ideally to use with linked lists. If you want to use a standard library function, you can allocate a temporary array of pointers, fill it in with pointers to all your list nodes, call qsort, and finally rebuild the list pointers based on the sorted array. 


Q 49: How can I sort more data than will fit in memory? 

A: You want an ``external sort,'' which you can read about in Knuth, Volume 3. The basic idea is to sort the data in chunks (as much as will fit in memory at one time), write each sorted chunk to a temporary file, and then merge the files. Your operating system may provide a general-purpose sort utility, and if so, you can try invoking it from within your program: see questions 19.27 and 19.30, and the example in question 19.28. 


Q 50: How can I get the current date or time of day in a C program? 

A: Just use the time, ctime, localtime and/or strftime functions. Here is a simple example: [footnote] 

#include <stdio.h>
#include <time.h>

int main()
{
	time_t now;
	time(&now);
	printf("It's %s", ctime(&now));
	return 0;
}


Calls to localtime and strftime look like this: 

	struct tm *tmp = localtime(&now);
	char fmtbuf[30];
	printf("It's %d:%02d:%02d\n",
		tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
	strftime(fmtbuf, sizeof fmtbuf, "%A, %B %d, %Y", tmp);
	printf("on %s\n", fmtbuf);

(Note that these functions take a pointer to the time_t variable, even when they will not be modifying it.[footnote] ) 

If you need sub-second resolution, see question 19.37. 


Q 51: I know that the library function localtime will convert a time_t into a broken-down struct tm, and that ctime will convert a time_t to a printable string. How can I perform the inverse operations of converting a struct tm or a string into a time_t? 

A: ANSI C specifies a library function, mktime, which converts a struct tm to a time_t. 

Converting a string to a time_t is harder, because of the wide variety of date and time formats which might be encountered. Some systems provide a strptime function, which is basically the inverse of strftime. Other popular functions are partime (widely distributed with the RCS package) and getdate (and a few others, from the C news distribution). See question 18.16. 





Q 52: How can I add N days to a date? How can I find the difference between two dates? 

A: The ANSI/ISO Standard C mktime and difftime functions provide some (limited) support for both problems. mktime accepts non-normalized dates, so it is straightforward to take a filled-in struct tm, add or subtract from the tm_mday field, and call mktime to normalize the year, month, and day fields (and incidentally convert to a time_t value). difftime computes the difference, in seconds, between two time_t values; mktime can be used to compute time_t values for two dates to be subtracted. 

However, these solutions are guaranteed to work correctly only for dates in the range which can be represented as time_t's [footnote] . The tm_mday field is an int, so day offsets of more than 32,736 or so may cause overflow. (See below for an alternative solution without these limitations.) Note also that at daylight saving time changeovers, local days are not 24 hours long, so be careful if you try to divide by 86,400 seconds/day. 

Here is a code fragment to compute the date 90 days past October 24, 1994: 

#include <stdio.h>
#include <time.h>

tm1.tm_mon = 10 - 1;
tm1.tm_mday = 24;
tm1.tm_year = 1994 - 1900;
tm1.tm_hour = tm1.tm_min = tm1.tm_sec = 0;
tm1.tm_isdst = -1;

tm1.tm_mday += 90;

if(mktime(&tm1) == -1)
	fprintf(stderr, "mktime failed\n");
else	printf("%d/%d/%d\n",
		tm1.tm_mon+1, tm1.tm_mday, tm1.tm_year+1900);

(Setting tm_isdst to -1 helps to guard against daylight saving time anomalies; setting tm_hour to 12 would, too.) 

Here is a piece of code to compute the difference in days between February 28 and March 1 in the year 2000: 

	struct tm tm1, tm2;
	time_t t1, t2;

	tm1.tm_mon = 2 - 1;
	tm1.tm_mday = 28;
	tm1.tm_year = 2000 - 1900;
	tm1.tm_hour = tm1.tm_min = tm1.tm_sec = 0;
	tm1.tm_isdst = -1;

	tm2.tm_mon = 3 - 1;
	tm2.tm_mday = 1;
	tm2.tm_year = 2000 - 1900;
	tm2.tm_hour = tm2.tm_min = tm2.tm_sec = 0;
	tm2.tm_isdst = -1;

	t1 = mktime(&tm1);
	t2 = mktime(&tm2);
	
	if(t1 == -1 || t2 == -1)
		fprintf(stderr, "mktime failed\n");
	else {
		long d = (difftime(t2, t1) + 86400L/2) / 86400L;
		printf("%ld\n", d);
	}

(The addition of 86400L/2 rounds the difference to the nearest day; see also question 14.6.) 

Another approach to both problems, which will work over a much wider range of dates, is to use ``Julian day numbers''. A Julian day number is the number of days since January 1, 4013 BC. [footnote] Given ToJul and FromJul routines declared as 

/* returns Julian for month, day, year */
long ToJul(int month, int day, int year);

/* returns month, day, year for jul */
void FromJul(long jul, int *monthp, int *dayp, int *yearp);

adding n days to a date can be implemented as 
	int n = 90;
	int month, day, year;
	FromJul(ToJul(10, 24, 1994) + n, &month, &day, &year);

and the number of days between two dates is 
	ToJul(3, 1, 2000) - ToJul(2, 28, 2000)

Code for handling Julian day numbers can be found in the Snippets collection (see question 18.15c), the Simtel/Oakland archives (file JULCAL10.ZIP, see question 18.16), and the ``Date conversions'' article mentioned in the References. 

See also questions 13.13, 20.31, and 20.32. 

Additional links: 

further explanation by Mark Brader 

more code for date-difference and day-of-week calculation by Branko Radovanovic 


Q 53: How can I get random integers in a certain range? 

A: The obvious way, 

	rand() % N		/* POOR */

(which tries to return numbers from 0 to N-1) is poor, because the low-order bits of many random number generators are distressingly non-random. (See question 13.18.) A better method is something like 
	(int)((double)rand() / ((double)RAND_MAX + 1) * N)


If you'd rather not use floating point, another method is 

	rand() / (RAND_MAX / N + 1)

If you just need to do something with probability 1/N, you could use 
	if(rand() < (RAND_MAX+1u) / N)

All these methods obviously require knowing RAND_MAX (which ANSI #defines in <stdlib.h>), and assume that N is much less than RAND_MAX. 

When N is close to RAND_MAX, and if the range of the random number generator is not a multiple of N (i.e. if (RAND_MAX+1) % N != 0), all of these methods break down: some outputs occur more often than others. (Using floating point does not help; the problem is that rand returns RAND_MAX+1 distinct values, which cannot always be evenly divvied up into N buckets.) If this is a problem, about the only thing you can do is to call rand multiple times, discarding certain values: 

	unsigned int x = (RAND_MAX + 1u) / N;
	unsigned int y = x * N;
	unsigned int r;
	do {
		r = rand();
	} while(r >= y);
	return r / x;


For any of these techniques, it's straightforward to shift the range, if necessary; numbers in the range [M, N] could be generated with something like 

	M + rand() / (RAND_MAX / (N - M + 1) + 1)


(Note, by the way, that RAND_MAX is a constant telling you what the fixed range of the C library rand function is. You cannot set RAND_MAX to some other value, and there is no way of requesting that rand return numbers in some other range.) 

If you're starting with a random number generator which returns floating-point values between 0 and 1 (such as the last version of PMrand alluded to in question 13.15, or drand48 in question 13.21), all you have to do to get integers from 0 to N-1 is multiply the output of that generator by N: 

	(int)(drand48() * N)


Q 54: When I set a float variable to, say, 3.1, why is printf printing it as 3.0999999? 

A: Most computers use base 2 for floating-point numbers as well as for integers, and just as for base 10, not all fractions are representable exactly in base 2. It's well-known that in base 10, a fraction like 1/3 = 0.333333... repeats infinitely. It turns out that in base 2, one tenth is also an infinitely-repeating fraction (0.0001100110011...), so exact decimal fractions such as 3.1 cannot be represented exactly in binary. Depending on how carefully your compiler's binary/decimal conversion routines (such as those used by printf) have been written, you may see discrepancies when numbers not exactly representable in base 2 are assigned or read in and then printed (i.e. converted from base 10 to base 2 and back again). [footnote] See also question 14.6. 



Q 55: How can I write a function that takes a format string and a variable number of arguments, like printf, and passes them to printf to do most of the work? 

A: Use vprintf, vfprintf, or vsprintf. These routines are like their counterparts printf, fprintf, and sprintf, except that instead of a variable-length argument list, they accept a single va_list pointer. 

As an example, here is an error function which prints an error message, preceded by the string ``error: '' and terminated with a newline: 

#include <stdio.h>
#include <stdarg.h>

void error(const char *fmt, ...)
{
	va_list argp;
	fprintf(stderr, "error: ");
	va_start(argp, fmt);
	vfprintf(stderr, fmt, argp);
	va_end(argp);
	fprintf(stderr, "\n");
}

See also question 15.7. 


Q 56: How can I discover how many arguments a function was actually called with? 

A: This information is not available to a portable program. Some old systems provided a nonstandard nargs function, but its use was always questionable, since it typically returned the number of words passed, not the number of arguments. (Structures, long ints, and floating point values are usually passed as several words.) 

Any function which takes a variable number of arguments must be able to determine from the arguments themselves how many of them there are. printf-like functions do this by looking for formatting specifiers (%d and the like) in the format string (which is why these functions fail badly if the format string does not match the argument list). Another common technique, applicable when the arguments are all of the same type, is to use a sentinel value (often 0, -1, or an appropriately-cast null pointer) at the end of the list (see the execl and vstrcat examples in questions 5.2 and 15.4). Finally, if the types are predictable, you can pass an explicit count of the number of variable arguments (although it's usually a nuisance for the caller to supply). 



Q 57: I can't get va_arg to pull in an argument of type pointer-to-function. 


A: Try using a typedef for the function pointer type. 

The type-rewriting games which the va_arg macro typically plays are stymied by overly-complicated types such as pointer-to-function. To illustrate, a simplified implementation of va_arg is 

	#define va_arg(argp, type) \
		(*(type *)(((argp) += sizeof(type)) - sizeof(type)))

where argp's type (va_list) is char *. When you attempt to invoke 
	va_arg(argp, int (*)())

the expansion is 
	(*(int (*)() *)(((argp) += sizeof(int (*)())) - sizeof(int (*)())))

which is a syntax error (the first cast (int (*)() *) is meaningless). [footnote] 

If you use a typedef for the function pointer type, however, all will be well. Given 

	typedef int (*funcptr)();

the expansion of 
	va_arg(argp, funcptr)

is 
	(*(funcptr *)(((argp) += sizeof(funcptr)) - sizeof(funcptr)))

which works correctly. 



Q 58: How can I write a function which takes a variable number of arguments and passes them to some other function (which takes a variable number of arguments)? 

A: In general, you cannot. Ideally, you should provide a version of that other function which accepts a va_list pointer. 

Suppose you want to write a faterror function which will print a fatal error message, then exit. You might like to write it in terms of the error function of question 15.5: 

	void faterror(const char *fmt, ...)
	{
		error(fmt, what goes here? );
		exit(EXIT_FAILURE);
	}

but it's not obvious how to hand faterror's arguments off to error. 

Proceed as follows. First split up the existing error function to create a new verror which accepts not a variable argument list but a single va_list pointer. (Note that doing so is little extra work, because verror contains much of the code that used to be in error, and the new error becomes a simple wrapper around verror.) 

#include <stdio.h>
#include <stdarg.h>

void verror(const char *fmt, va_list argp)
{
	fprintf(stderr, "error: ");
	vfprintf(stderr, fmt, argp);
	fprintf(stderr, "\n");
}

void error(const char *fmt, ...)
{
	va_list argp;
	va_start(argp, fmt);
	verror(fmt, argp);
	va_end(argp);
}


Now you can write faterror, and have it call verror, too: 

#include <stdlib.h>

void faterror(const char *fmt, ...)
{
	va_list argp;
	va_start(argp, fmt);
	verror(fmt, argp);
	va_end(argp);
	exit(EXIT_FAILURE);
}

Note that the relation between error and verror is exactly that which holds between e.g. printf and vprintf. In fact, as Chris Torek has observed, whenever you find yourself writing a varargs function, it's a good idea to write two versions of it: one (like verror) which accepts a va_list and does the work, and one (like the revised error) which is a simple wrapper. The only real restriction on this technique is that a function like verror can scan the arguments just once; there is no way for it to reinvoke va_start. 

If you do not have the option of rewriting the lower-level function (error, in this example) to accept a va_list, such that you find yourself needing to pass the variable arguments that one function (e.g. faterror) receives on to another as actual arguments, no portable solution is possible. (The problem could perhaps be solved by resorting to machine-specific assembly language; see also question 15.13.) 

One approach that would not work would be something like 

	void faterror(const char *fmt, ...)
	{
		va_list argp;
		va_start(argp, fmt);
		error(fmt, argp);		/* WRONG */
		va_end(argp);
		exit(EXIT_FAILURE);
	}

A va_list is not itself a variable argument list; it's really sort of a pointer to one. That is, a function which accepts a va_list is not itself varargs, nor vice versa. 

Another kludge that is sometimes used, and which sometimes works even though it is grossly nonportable, is to use a lot of int arguments, hoping that there are enough of them and that they can somehow pass through pointer, floating-point, and other arguments as well: 

	void faterror(fmt, a1, a2, a3, a4, a5, a6)
	char *fmt;
	int a1, a2, a3, a4, a5, a6;
	{
		error(fmt, a1, a2, a3, a4, a5, a6);	/* VERY WRONG */
		exit(EXIT_FAILURE);
	}

This example is presented only for the purpose of urging you not to use it; please don't try it just because you saw it here. 





Q 59: How can I call a function with an argument list built up at run time? 

A: There is no guaranteed or portable way to do this. If you're curious, this list's editor has a few wacky ideas you could try... 

Instead of an actual argument list, you might consider passing an array of generic (void *) pointers. The called function can then step through the array, much like main() might step through argv. (Obviously this works only if you have control over all the called functions.) 


Q 60: This program crashes before it even runs! (When single-stepping with a debugger, it dies before the first statement in main.) 

A: You probably have one or more very large (kilobyte or more) local arrays. Many systems have fixed-size stacks, and even those which perform dynamic stack allocation automatically (e.g. Unix) can be confused when the stack tries to grow by a huge chunk all at once. It is often better to declare large arrays with static duration (unless of course you need a fresh set with each recursive call, in which case you could dynamically allocate them with malloc; see also question 1.31). 

Other possibilities are that your program has been linked incorrectly (combining object modules compiled with different compilation options, or using improper dynamic libraries), or that run-time dynamic library linking is failing for some reason, or that you have somehow misdeclared main. 






Q 61: I have a program that seems to run correctly, but it crashes as it's exiting, after the last statement in main(). What could be causing this? 

A: There are at least three things to look for: 

If a semicolon in a previous declaration is missing, main might be inadvertently declared as returning a structure, conflicting with the run-time startup code's expectations. See questions 2.18, 10.9, 11.12b, and 11.14a. 
If setbuf or setvbuf is called, and if the supplied buffer is an automatic, local variable of main (or any function), the buffer may not exist any more by the time the stdio library tries to perform its final cleanup. 
A cleanup function registered by atexit may have an error. Perhaps it is trying to reference data local to main or to some other function which no longer exists. 
(The second and third problems are actually closely related to question 7.5a; see also question 11.16.) 


Q 62: Why does this code: 

char *p = "hello, world!";
p[0] = 'H';
crash? 

A: String constants are in fact constant. The compiler may place them in nonwritable storage, and it is therefore not safe to modify them. When you need writable strings, you must allocate writable memory for them, either by declaring an array, or by calling malloc. Try 

	char a[] = "hello, world!";


By the same argument, a typical invocation of the old Unix mktemp routine 

	char *tmpfile = mktemp("/tmp/tmpXXXXXX");

is nonportable; the proper usage is 
	char tmpfile[] = "/tmp/tmpXXXXXX";
	mktemp(tmpfile);




Q 63: I've got some code that's trying to unpack external structures, but it's crashing with a message about an ``unaligned access.'' What does this mean? The code looks like this: 

struct mystruct {
	char c;
	long int i32;
	int i16;
} s;

char buf[7], *p;
fread(buf, 7, 1, fp);
p = buf;
s.c = *p++;
s.i32 = *(long int *)p;
p += 4;
s.i16 = *(int *)p;

A: The problem is that you're playing too fast and loose with your pointers. Some machines require that data values be stored at appropriately aligned addresses. For instance, two-byte short ints might be constrained to sit at even addresses, and four-byte long ints at multiples of four. (See also question 2.12.) By converting a char * (which can point to any byte) to an int * or long int *, and then indirecting on it, you can end up asking the processor to fetch a multibyte value from an unaligned address, which it isn't willing to do. 

A better way to unpack external structures is with code like 

	unsigned char *p = buf;

	s.c = *p++;

	s.i32 = (long)*p++ << 24;
	s.i32 |= (long)*p++ << 16;
	s.i32 |= (unsigned)(*p++ << 8);
	s.i32 |= *p++;

	s.i16 = *p++ << 8;
	s.i16 |= *p++;


This code also gives you control over byte order. (This example, though, assumes that a char is 8 bits, and that the long int and int being unpacked from the ``external structure'' are 32 and 16 bits, respectively.) See question 12.42 (which contains some similar code) for a few explanations and caveats. 

See also question 4.5. 



Q 64: What do ``Segmentation violation'', ``Bus error'', and ``General protection fault'' mean? What's a ``core dump''? 

A: These symptoms (and any similar messages having to do with memory access violations or protection faults) generally mean that your program tried to access memory it shouldn't have, invariably as a result of stack corruption or improper pointer use. Likely causes are: 

overflow of local (``automatic,'' stack-allocated) arrays 
inadvertent use of null pointers (see also questions 5.2 and 5.20) 
uninitialized, misaligned, or otherwise improperly allocated pointers (see questions 7.1, 7.2, and 16.7) 
stale aliases to memory that has been relocated (see question 7.29) 
corruption of the malloc arena (see question 7.19) 
attempts to modify read-only values (those declared const, and string literals--see question 1.32) 
mismatched function arguments, especially involving pointers; two possibilities are scanf (see question 12.12) and fprintf (make sure it receives its first FILE * argument) 

Under Unix, any of these problems almost invariably leads to a ``core dump'': a file named core, [footnote] created in the current directory, containing a memory image of the crashed process, for debugging. 

The distinction between ``Bus error'' and ``Segmentation Violation'' may or may not be significant; different versions of Unix generate these signals under different sets of circumstances. Roughly speaking, a segmentation violation indicates an attempt to access memory which doesn't even exist, and a bus error indicates an attempt to access memory in an illegal way (perhaps due to an unaligned pointer; see question 16.7). 


Q 65: I've seen function declarations that look like this: 

extern int func __((int, int));
What are those extra parentheses and underscores for? 

A: They're part of a trick which allows the prototype part of the function declaration to be turned off for a pre-ANSI compiler. Somewhere else is a conditional definition of the __ macro like this: 

	#ifdef __STDC__
	#define __(proto) proto
	#else
	#define __(proto) ()
	#endif

The extra parentheses in the invocation 
	extern int func __((int, int));

are required so that the entire prototype list (perhaps containing many commas) is treated as the single argument expected by the macro. 


Q 66: I came across some code that puts a (void) cast before each call to printf. Why? 

A: printf does return a value (the number of characters printed, or an error code), though few programs bother to check the return values from each call. Since some compilers (and lint) will warn about discarded return values, an explicit cast to (void) is a way of saying ``Yes, I've decided to ignore the return value from this call, but please continue to warn me about other (perhaps inadvertently) ignored return values.'' It's also common to use void casts on calls to strcpy and strcat, since the return value is never surprising. 



Q 67: How can I read a single character from the keyboard without waiting for the RETURN key? How can I stop characters from being echoed on the screen as they're typed? 

A: Alas, there is no standard or portable way to do these things in C. Concepts such as screens and keyboards are not even mentioned in the Standard, which deals only with simple I/O ``streams'' of characters. 

Input to a computer program typically passes through several stages. At the lowest level, device-dependent routines within the operating system handle the details of interfacing with particular devices such as keyboards, serial lines, disk drives, etc. Above that, modern operating systems tend to have a device-independent I/O layer, unifying access to any file or device. Finally, a C program is usually insulated from the operating system's I/O facilities by the portable functions of the stdio library. 

At some level, interactive keyboard input is usually collected and presented to the requesting program a line at a time. This gives the operating system a chance to support input line editing (backspace/delete/rubout, etc.) in a consistent way, without requiring that it be built into every program. Only when the user is satisfied and presses the RETURN key (or equivalent) is the line made available to the calling program. Even if the calling program appears to be reading input a character at a time (with getchar or the like), the first call blocks until the user has typed an entire line, at which point potentially many characters become available and many character requests (e.g. getchar calls) are satisfied in quick succession. 

When a program wants to read each character immediately as it arrives, its course of action will depend on where in the input stream the line collection is happening and how it can be disabled. Under some systems (e.g. MS-DOS, VMS in some modes), a program can use a different or modified set of OS-level input calls to bypass line-at-a-time input processing. Under other systems (e.g. Unix, VMS in other modes), the part of the operating system responsible for serial input (often called the ``terminal driver'') must be placed in a mode which turns off line-at-a-time processing, after which all calls to the usual input routines (e.g. read, getchar, etc.) will return characters immediately. Finally, a few systems (particularly older, batch-oriented mainframes) perform input processing in peripheral processors which cannot be told to do anything other than line-at-a-time input. 

Therefore, when you need to do character-at-a-time input (or disable keyboard echo, which is an analogous problem), you will have to use a technique specific to the system you're using, assuming it provides one. Since comp.lang.c is oriented towards those topics that the C language has defined support for, you will usually get better answers to other questions by referring to a system-specific newsgroup such as comp.unix.questions or comp.os.msdos.programmer, and to the FAQ lists for these groups. Note that the answers may differ even across variants of otherwise similar systems (e.g. across different variants of Unix); bear in mind when answering system-specific questions that the answer that applies to your system may not apply to everyone else's. 

However, since these questions are frequently asked here, here are brief answers for some common situations. 

Depending on which operating system you're using and what libraries you have available, you may be able to use one (or more!) of the following techniques: 

If you can use the ``curses'' library, you can call cbreak [footnote] (and perhaps noecho), after which calls to getch will return characters immediately. 
If all you're trying to do is read a short password without echo, you may be able to use a function called getpass, if it's available. (Another possibility for hiding typed passwords is to select black characters on a black background.) 
Under ``classic'' versions of Unix, use ioctl and the TIOCGETP and TIOCSETP (or TIOCSETN) requests on file descriptor 0 to manipulate the sgttyb structure, defined in <sgtty.h> and documented in tty(4). In the sg_flags field, set the CBREAK (or RAW) bit, and perhaps clear the ECHO bit. 
Under System V Unix, use ioctl and the TCGETAW and TCSETAW requests on file descriptor 0 to manipulate the termio structure, defined in <termio.h>. In the c_lflag field, clear the ICANON (and perhaps ECHO) bits. Also, set c_cc[VMIN] to 1 and c_cc[VTIME] to 0. 
Under any operating system (Unix or otherwise) offering POSIX compatibility, use the tcgetattr and tcsetattr calls on file descriptor 0 to manipulate the termios structure, defined in <termios.h>. In the c_lflag field, clear the ICANON (and perhaps ECHO) bits. Also, set c_cc[VMIN] to 1 and c_cc[VTIME] to 0. 
In a pinch, under Unix, use system (see question 19.27) to invoke the stty command to set terminal driver modes (as in the preceding three items). 
Under MS-DOS, use getch or getche, or the corresponding BIOS interrupts. 
Under VMS, try the Screen Management (SMG$) routines, or curses, or issue low-level $QIO's with the IO$_READVBLK function code (and perhaps IO$M_NOECHO, and others) to ask for one character at a time. (It's also possible to set character-at-a-time or ``pass through'' modes in the VMS terminal driver.) 
Under other operating systems, you're on your own. 

(As an aside, note that simply using setbuf or setvbuf to set stdin to unbuffered will not generally serve to allow character-at-a-time input.) 

If you change terminal modes, save a copy the initial state and be sure to restore it no matter how your program terminates. 

If you're trying to write a portable program, a good approach is to define your own suite of three functions to (1) set the terminal driver or input system into character-at-a-time mode (if necessary), (2) get characters, and (3) return the terminal driver to its initial state when the program is finished. (Ideally, such a set of functions might be part of the C Standard, some day.) 

As an example, here is a tiny test program which prints the decimal values of the next ten characters as they are typed, without waiting for RETURN. It is written in terms of three functions, as described, and is followed by implementations of the three functions for curses, classic Unix, System V Unix, and MS-DOS. (The on-line archives associated with this list contain a more complete set of functions.) 

#include <stdio.h>

main()
{
	int i;
	if(tty_break() != 0)
		return 1;
	for(i = 0; i < 10; i++)
		printf(" = %d\n", tty_getchar());
	tty_fix();
	return 0;
}


This implementation of the three functions is for curses: 

#include <curses.h>

int tty_break()
{
	initscr();
	cbreak();
	return 0;
}

int tty_getchar()
{
	return getch();
}

int tty_fix()
{
	endwin();
	return 0;
}


Here is the code for ``classic'' (V7, BSD) Unix: 

#include <stdio.h>
#include <sgtty.h>

static struct sgttyb savemodes;
static int havemodes = 0;

int tty_break()
{
	struct sgttyb modmodes;
	if(ioctl(fileno(stdin), TIOCGETP, &savemodes) < 0)
		return -1;
	havemodes = 1;
	modmodes = savemodes;
	modmodes.sg_flags |= CBREAK;
	return ioctl(fileno(stdin), TIOCSETN, &modmodes);
}

int tty_getchar()
{
	return getchar();
}

int tty_fix()
{
	if(!havemodes)
		return 0;
	return ioctl(fileno(stdin), TIOCSETN, &savemodes);
}


The code for System V Unix is similar: 

#include <stdio.h>
#include <termio.h>

static struct termio savemodes;
static int havemodes = 0;

int tty_break()
{
	struct termio modmodes;
	if(ioctl(fileno(stdin), TCGETA, &savemodes) < 0)
		return -1;
	havemodes = 1;
	modmodes = savemodes;
	modmodes.c_lflag &= ~ICANON;
	modmodes.c_cc[VMIN] = 1;
	modmodes.c_cc[VTIME] = 0;
	return ioctl(fileno(stdin), TCSETAW, &modmodes);
}

int tty_getchar()
{
	return getchar();
}

int tty_fix()
{
	if(!havemodes)
		return 0;
	return ioctl(fileno(stdin), TCSETAW, &savemodes);
}


Finally, here is an implementation for MS-DOS: 

int tty_break() { return 0; }

int tty_getchar()
{
	return getche();
}

int tty_fix() { return 0; }


Turning off echo is left as an exercise for the reader. 

For detailed information on terminal (keyboard and screen) I/O programming, see an FAQ list, book, or documentation set specific to your operating system. (Note that there can be many more details to take care of, e.g. special characters to disable as well as more mode bits to toggle, than were mentioned above.) 


Q 68: How can I find out if there are characters available for reading (and if so, how many)? Alternatively, how can I do a read that will not block if there are no characters available? 

A: These, too, are entirely operating-system-specific. Some versions of curses have a nodelay function. Depending on your system, you may also be able to use ``nonblocking I/O'', or a system call named select or poll, or the FIONREAD ioctl, or c_cc[VTIME], or kbhit, or rdchk, or the O_NDELAY option to open or fcntl. You can also try setting an alarm to cause a blocking read to time out after a certain interval (under Unix, look at alarm, signal, and maybe setitimer). 

If what you're trying to do is read input from several sources without blocking, you will definitely want to use some kind of a ``select'' call, because a busy-wait, polling loop is terribly inefficient on a multitasking system. 



Q 69: How do I read the arrow keys? What about function keys? 

A: Terminfo, some versions of termcap, and some versions of curses have support for these non-ASCII keys. Typically, a special key sends a multicharacter sequence (usually beginning with ESC, '\033'); parsing these can be tricky. (curses will do the parsing for you, if you call keypad first.) 

Under MS-DOS, if you receive a character with value 0 (not '0'!) while reading the keyboard, it's a flag indicating that the next character read will be a code indicating a special key. See any DOS programming guide for lists of keyboard scan codes. (Very briefly: the up, left, right, and down arrow keys are 72, 75, 77, and 80, and the function keys are 59 through 68.) 


Q 70: How can I direct output to the printer? 

A: Under Unix, either use popen (see question 19.30) to write to the lp or lpr program, or perhaps open a special file like /dev/lp. Under MS-DOS, write to the (nonstandard) predefined stdio stream stdprn, or open the special files PRN or LPT1. Under some circumstances, another (and perhaps the only) possibility is to use a window manager's screen-capture function, and print the resulting bitmap. 



Q 71: How do I send escape sequences to control a terminal or other device? 

A: If you can figure out how to send characters to the device at all (see question 19.8), it's easy enough to send escape sequences. In ASCII, the ESC code is 033 (27 decimal), so code like 

	fprintf(ofd, "\033[J");

sends the sequence ESC [ J . 

Some programmers prefer to parameterize the ESC code, like this: 

	#define ESC 033

	fprintf(ofd, "%c[J", ESC);




Q 72: How can I access an I/O board directly? 

A: At one level, at least, it's quite simple: you have a device register which is actually wired up so that the bits written to it get coverted to actual voltage levels in the real world that you can do interesting things with. In general, there are two ways to get the bits in and out. (A particular I/O board will use one method or the other; you'll need to consult its documentation for details.) 

If the device is accessed via a dedicated ``I/O port'', use system-specific functions to communicate with it. Under MS-DOS, for example, there were quasistandard ``inport'' and ``outport'' instructions. 
If the device uses ``memory-mapped I/O'', that is, if the device register(s) are accessed as if they were normal memory at particular, known locations within the processor's addressing space, use contrived pointer variables to access those locations. See question 19.25. 



Q 73: How can I send mail from within a C program? 

A: Under Unix, open a pipe to the mail program, or perhaps /usr/lib/sendmail. See question 19.30




Q 74: How can I check whether a file exists? I want to warn the user if a requested input file is missing. 

A: It's surprisingly difficult to make this determination reliably and portably. Any test you make can be invalidated if the file is created or deleted (i.e. by some other process) between the time you make the test and the time you try to open the file. 

Three possible test functions are stat, access, and fopen. (To make an approximate test using fopen, just open for reading and close immediately, although failure does not necessarily indicate nonexistence.) Of these, only fopen is widely portable, and access, where it exists, must be used carefully if the program uses the Unix set-UID feature. (If you have the choice, the best compromise is probably one of the stat functions.) 

Rather than trying to predict in advance whether an operation such as opening a file will succeed, it's often better to try it, check the return value, and complain if it fails. (Obviously, this approach won't work if you're trying to avoid overwriting an existing file, unless you've got something like the O_EXCL file opening option available, which does just what you want in this case.) 




Q 75: How can I find out the size of a file, prior to reading it in? 

A: If the ``size of a file'' is the number of characters you'll be able to read from it in C (or which were written to it by a previous program), it can be difficult or impossible to determine this number exactly (other than by reading the whole file). 

Under Unix, the stat call (specifically, the st_size field of the stat structure) will give you an exact answer. [footnote] Several other systems supply a Unix-like stat call, but the sizes reported for text files may be approximate (due to differing end-of-line representations; see question 12.40). You can open the file and use fstat, or fseek to the end of the file and then use ftell, but these tend to have the same problems: fstat is not portable, and generally tells you the same thing stat tells you; ftell is not guaranteed to return a byte count except for binary files (but, strictly speaking, binary files don't necessarily support fseek to SEEK_END at all). Some systems provide functions called filesize or filelength, but these are obviously not portable, either. 

Are you sure you have to determine the file's size in advance? Since the most accurate way of determining the size of a file as a C program will see it is to open the file and read it, perhaps you can rearrange the code to learn the size as it reads. (In general, your program should behave gracefully if the number of characters actually read does not match prior expectations, since any advance determination of the size might be approximate.) See also questions 7.29, 7.30, and 20.2. 



Q 76: How can a file be shortened in-place without completely clearing or rewriting it? 

A: BSD systems provide ftruncate, several others supply chsize, and a few may provide a (possibly undocumented) fcntl option F_FREESP. Under MS-DOS, you can sometimes use write(fd, "", 0). However, there is no portable solution, nor a way to  delete blocks at the beginning or in the middle. See also question 19.14. 



Q 77: fopen isn't letting me open files like "$HOME/.profile" and "~/.myrcfile". 

A: Under Unix, at least, environment variables like $HOME, along with the home-directory notation involving the ~ character, are expanded by the shell, and there's no mechanism to perform these expansions automatically when you call fopen. 



Q 78: How can I find out how much free space is available on disk? 

A: There is no portable way. Under some versions of Unix you can call statfs. Under MS-DOS, use interrupt 0x21 subfunction 0x36, or perhaps a routine such as diskfree. Another possibility is to use popen (see question 19.30) to invoke and read the output of a ``disk free'' command (df on Unix). 

(Note that the amount of free space apparently available on a disk may not match the size of the largest file you can store, for all sorts of reasons.) 



Q 79: How can I read a directory in a C program? 

A: See if you can use the opendir and readdir functions, which are part of the POSIX standard and are available on most Unix variants. Implementations also exist for MS-DOS, VMS, and other systems. (MS-DOS also has FINDFIRST and FINDNEXT routines which do essentially the same thing, and MS Windows has FindFirstFile and FindNextFile.) readdir returns just the file names; if you need more information about the file, try calling stat. To match filenames to some wildcard pattern, see question 13.7. 

Here is a tiny example which lists the files in the current directory: 

#include <stdio.h>
#include <sys/types.h>
#include <dirent.h>

main()
{
	struct dirent *dp;
	DIR *dfd = opendir(".");
	if(dfd != NULL) {
		while((dp = readdir(dfd)) != NULL)
			printf("%s\n", dp->d_name);
		closedir(dfd);
	}
	return 0;
}

(On older systems, the header file to #include may be <direct.h> or <dir.h>, and the pointer returned by readdir may be a struct direct *. This example assumes that "." is a synonym for the current directory.) 

In a pinch, you could use popen (see question 19.30) to call an operating system list-directory program, and read its output. (If you only need the filenames displayed to the user, you could conceivably use system; see question 19.27.) 



Q 80: How can I find out how much memory is available? 

A: Your operating system may provide a routine which returns this information, but it's quite system-dependent. (Also, the number may vary over time.) If you're trying to predict whether you'll be able to allocate a certain amount of memory, just try it--call malloc (requesting that amount) and check the return value. 



Q 81: How can I invoke another program (a standalone executable, or an operating system command) from within a C program? 

A: Use the library function system, which does exactly that. 

Some systems also provide a family of spawn routines which accomplish approximately the same thing. system is more ``portable'' in that it is required under the ANSI C Standard, although the interpretation of the command string--its syntax and the set of commands accepted--will obviously vary tremendously. 

The system function ``calls'' a command in the manner of a subroutine, and control eventually returns to the calling program. If you want to overlay the calling program with another program (that is, a ``chain'' operation) you'll need a system-specific routine, such as the exec family on Unix. 

Note that system's return value is at best the command's exit status (although even that is not guaranteed), and usually has nothing to do with the output of the command. 



Q 82: How can I call system when parameters (filenames, etc.) of the executed command aren't known until run time? 

A: Just use sprintf (or perhaps strcpy and strcat) to build the command string in a buffer, then call system with that buffer. (Make sure the buffer is allocated with enough space; see also questions 7.2 and 12.21.) 

Here is a contrived example suggesting how you might build a data file, then sort it (assuming the existence of a sort utility, and Unix- or MS-DOS-style input/output redirection): 

	char *datafile = "file.dat";
	char *sortedfile = "file.sort";
	char cmdbuf[50];
	FILE *fp = fopen(datafile, "w");

	/* ...write to fp to build data file... */

	fclose(fp);

	sprintf(cmdbuf, "sort < %s > %s", datafile, sortedfile);
	system(cmdbuf);

	fp = fopen(sortedfile, "r");
	/* ...now read sorted data from fp... */



Q 83: How do I get an accurate error status return from system on MS-DOS? 

A: You can't; COMMAND.COM doesn't tend to provide one. If you don't need COMMAND.COM's services (i.e. if you're just trying to invoke a simple program, without I/O redirection and such) try one of the spawn routines, instead. 



Q 84: How can I invoke another program or command and trap its output? 

A: Unix and some other systems provide a popen function, which sets up a stdio stream on a pipe connected to the process running a command, so that the calling program can read the output (or alternatively supply the input). Using popen, the last example from question 19.28 would look like 

	extern FILE *popen();

	sprintf(cmdbuf, "sort < %s", datafile);

	fp = popen(cmdbuf, "r");

	/* ...now read sorted data from fp... */

	pclose(fp);

(Do be sure to call pclose, as shown; leaving it out will seem to work at first but may eventually run you out of processes or file descriptors.) 

If you can't use popen, you may be able to use system, with the output going to a file which you then open and read, as the code in question 19.28 was doing already. [footnote] 

If you're using Unix and popen isn't sufficient, you can learn about pipe, dup, fork, and exec. 

(One thing that probably would not work, by the way, would be to use freopen.) 



Q 85: How can my program discover the complete pathname to the executable from which it was invoked? 

A: argv[0] may contain all or part of the pathname, or it may contain nothing. You may be able to duplicate the command language interpreter's search path logic to locate the executable if the name in argv[0] is present but incomplete. However, there is no guaranteed solution. 



Q 86: How can a process change an environment variable in its caller? 

A: It may or may not be possible to do so at all. Different operating systems implement global name/value functionality similar to the Unix environment in different ways. Whether the ``environment'' can be usefully altered by a running program, and if so, how, is system-dependent. 

Under Unix, a process can modify its own environment (some systems provide setenv or putenv functions for the purpose), and the modified environment is generally passed on to child processes, but it is not propagated back to the parent process. (The environment of the parent process can only be altered if the parent is explicitly set up to listen for some kind of change requests. The conventional execution of the BSD ``tset'' program in .profile and .login files effects such a scheme.) Under MS-DOS, it's possible to manipulate the master copy of the environment, but the required techniques are arcane. (See an MS-DOS FAQ list.) 



Q 87: How can I read in an object file and jump to locations in it? 

A: You want a dynamic linker or loader. It may be possible to malloc some space and read in object files, but you have to know an awful lot about object file formats, relocation, etc., and this approach can't work if code and data reside in separate address spaces or if code is otherwise privileged. 

Under BSD Unix, you could use system and ld -A to do the linking for you. Many versions of SunOS and System V have the -ldl library containing routines like dlopen and dlsym which allow object files to be dynamically loaded. Under VMS, use LIB$FIND_IMAGE_SYMBOL. GNU has a package called ``dld''. See also question 15.13. 




Q 88: How can I trap or ignore keyboard interrupts like control-C? 

A: The basic step is to call signal, either as 

	#include <signal.h>
	signal(SIGINT, SIG_IGN);

to ignore the interrupt signal, or as 
	extern void func(int);
	signal(SIGINT, func);

to cause control to transfer to function func on receipt of an interrupt signal. [footnote] 

On a multi-tasking system such as Unix, it's best to use a slightly more involved technique: 

	extern void func(int);
	if(signal(SIGINT, SIG_IGN) != SIG_IGN)
		signal(SIGINT, func);

The test and extra call ensure that a keyboard interrupt typed in the foreground won't inadvertently interrupt a program running in the background (and it doesn't hurt to code calls to signal this way on any system). [footnote] 

On some systems, keyboard interrupt handling is also a function of the mode of the terminal-input subsystem; see question 19.1. On some systems, checking for keyboard interrupts is only performed when the program is reading input, and keyboard interrupt handling may therefore depend on which input routines are being called (and whether any input routines are active at all). On MS-DOS systems, setcbrk or ctrlbrk functions may also be involved. 



Q 89: What are ``near'' and ``far'' pointers? 

A: These days, they're pretty much obsolete; they're definitely system-specific. They had to do with 16-bit programming under MS-DOS and perhaps some early versions of Windows. If you really need to know, see a DOS- or Windows-specific programming reference. If you're using a machine which doesn't require (or permit) making the near/far pointer distinction, just delete the unnecessary ``near'' and ``far'' keywords (perhaps using the preprocessor: ``#define far /* nothing */''). 



Q 90: How can I return multiple values from a function? 

A: There are several ways of doing this. (These examples show hypothetical polar-to-rectangular coordinate conversion functions, which must return both an x and a y coordinate.) 

Pass pointers to several locations which the function can fill in: 
#include <math.h>

polar_to_rectangular(double rho, double theta,
		double *xp, double *yp)
{
	*xp = rho * cos(theta);
	*yp = rho * sin(theta);
}

...

	double x, y;
	polar_to_rectangular(1., 3.14, &x, &y);

Have the function return a structure containing the desired values: 
struct xycoord { double x, y; };

struct xycoord
polar_to_rectangular(double rho, double theta)
{
	struct xycoord ret;
	ret.x = rho * cos(theta);
	ret.y = rho * sin(theta);
	return ret;
}

...

	struct xycoord c = polar_to_rectangular(1., 3.14);

Use a hybrid: have the function accept a pointer to a structure, which it fills in: 
polar_to_rectangular(double rho, double theta,
		struct xycoord *cp)
{
	cp->x = rho * cos(theta);
	cp->y = rho * sin(theta);
}

...

	struct xycoord c;
	polar_to_rectangular(1., 3.14, &c);

(Another example of this technique is the Unix system call stat.) 
In a pinch, you could theoretically use global variables (though this is rarely a good idea). 




Q 91: How can I open files mentioned on the command line, and parse option flags? 

A: Here is a skeleton which implements a traditional Unix-style argv parse, handling option flags beginning with -, and optional filenames. (The two flags accepted by this example are -a and -b; -b takes an argument.) 

#include <stdio.h>
#include <string.h>
#include <errno.h>

main(int argc, char *argv[])
{
	int argi;
	int aflag = 0;
	char *bval = NULL;

	for(argi = 1; argi < argc && argv[argi][0] == '-'; argi++) {
		char *p;
		for(p = &argv[argi][1]; *p != '\0'; p++) {
			switch(*p) {
			case 'a':
				aflag = 1;
				printf("-a seen\n");
				break;

			case 'b':
				bval = argv[++argi];
				printf("-b seen (\"%s\")\n", bval);
				break;

			default:
				fprintf(stderr,
					"unknown option -%c\n", *p);
			}
		}
	}

	if(argi >= argc) {
		/* no filename arguments; process stdin */
		printf("processing standard input\n");
	} else {
		/* process filename arguments */

		for(; argi < argc; argi++) {
			FILE *ifp = fopen(argv[argi], "r");
			if(ifp == NULL) {
				fprintf(stderr, "can't open %s: %s\n",
					argv[argi], strerror(errno));
				continue;
			}

			printf("processing %s\n", argv[argi]);

			fclose(ifp);
		}
	}

	return 0;
}

(This code assumes that fopen sets errno when it fails, which is not guaranteed, but usually works, and makes error messages much more useful. See also question 20.4.) 

There are several canned functions available for doing command line parsing in a standard way; the most popular one is getopt (see also question 18.16). Here is the above example, rewritten to use getopt: 

extern char *optarg;
extern int optind;

main(int argc, char *argv[])
{
	int aflag = 0;
	char *bval = NULL;
	int c;

	while((c = getopt(argc, argv, "ab:")) != -1)
		switch(c) {
		case 'a':
			aflag = 1;
			printf("-a seen\n");
			break;

		case 'b':
			bval = optarg;
			printf("-b seen (\"%s\")\n", bval);
			break;
	}

	if(optind >= argc) {
		/* no filename arguments; process stdin */
		printf("processing standard input\n");
	} else {
		/* process filename arguments */

		for(; optind < argc; optind++) {
			FILE *ifp = fopen(argv[optind], "r");
			if(ifp == NULL) {
				fprintf(stderr, "can't open %s: %s\n",
					argv[optind], strerror(errno));
				continue;
			}

			printf("processing %s\n", argv[optind]);

			fclose(ifp);
		}
	}

	return 0;
}


The examples above overlook a number of nuances: a lone ``-'' is often taken to mean ``read standard input''; the marker ``--'' often signifies the end of the options (proper versions of getopt do handle this); it's traditional to print a usage message when a command is invoked with improper or missing arguments. 

If you're wondering how argv is laid out in memory, it's actually a ``ragged array''; see the picture in question 20.2. See also questions 8.2, 13.7, and 19.20. 



Q 92: How can I write data files which can be read on other machines with different word size, byte order, or floating point formats? 

A: The most portable solution is to use text files (usually ASCII), written with fprintf and read with fscanf or the like. (Similar advice also applies to network protocols.) Be skeptical of arguments which imply that text files are too big, or that reading and writing them is too slow. Not only is their efficiency frequently acceptable in practice, but the advantages of being able to interchange them easily between machines, and manipulate them with standard tools, can be overwhelming. 

If you must use a binary format, you can improve portability, and perhaps take advantage of prewritten I/O libraries, by making use of standardized formats such as Sun's XDR (RFC 1014), OSI's ASN.1 (referenced in CCITT X.409 and ISO 8825 ``Basic Encoding Rules''), CDF, netCDF, or HDF. See also questions 2.12, 12.38, and 12.42. 



Q 93: If I have a char * variable pointing to the name of a function, how can I call that function? Code like 

	extern int func(int, int);
	char *funcname = "func";
	int r = (*funcname)(1, 2);

or 
	r = (*(int (*)(int, int))funcname)(1, 2);

doesn't seem to work. 

A: By the time a program is running, information about the names of its functions and variables (the ``symbol table'') is no longer needed, and may therefore not be available. The most straightforward thing to do, therefore, is to maintain that information yourself, with a correspondence table of names and function pointers: 

int one_func(), two_func();
int red_func(), blue_func();

struct { char *name; int (*funcptr)(); } symtab[] = {
	"one_func",	one_func,
	"two_func",	two_func,
	"red_func",	red_func,
	"blue_func",	blue_func,
};

Then, search the table for the name, and call via the associated function pointer, with code like this: 
#include <stddef.h>

int (*findfunc(char *name))()
{
	int i;

	for(i = 0; i < sizeof(symtab) / sizeof(symtab[0]); i++) {
		if(strcmp(name, symtab[i].name) == 0)
			return symtab[i].funcptr;
		}

	return NULL;
}

...

	char *funcname = "one_func";
	int (*funcp)() = findfunc(funcname);
	if(funcp != NULL)
		(*funcp)();

The callable functions should all have compatible argument and return types. (Ideally, the function pointers would also specify the argument types.) 

It is sometimes possible for a program to read its own symbol table if it is still present, but it must first be able to find its own executable (see question 19.31), and it must know how to interpret the symbol table (some Unix C libraries provide an nlist function for this purpose). See also questions 2.15, 18.14, and 19.36. 



Q 94: How can I ensure that integer arithmetic doesn't overflow? 

A: The usual approach is to test the operands against the limits in the header file <limits.h> before doing the operation. For example, here is a ``careful'' addition function: 

int
chkadd(int a, int b)
{
	if(INT_MAX - b < a) {
		fputs("int overflow\n", stderr);
		return INT_MAX;
	}
	return a + b;
}



Q 95: How can I manipulate individual bits? 

A: Bit manipulation is straightforward in C, and commonly done. To extract (test) a bit, use the bitwise AND (&) operator, along with a bit mask representing the bit(s) you're interested in: 

	value & 0x04

To set a bit, use the bitwise OR (| or |=) operator: 
	value |= 0x04

To clear a bit, use the bitwise complement (~) and the AND (& or &=) operators: 
	value &= ~0x04

(The preceding three examples all manipulate the third-least significant, or 2**2, bit, expressed as the constant bitmask 0x04.) 

To manipulate an arbitrary bit, use the shift-left operator (<<) to generate the mask you need: 

	value & (1 << bitnumber)
	value |= (1 << bitnumber)
	value &= ~(1 << bitnumber)

Alternatively, you may wish to precompute an array of masks: 
	unsigned int masks[] =
		{0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};

	value & masks[bitnumber]
	value |= masks[bitnumber]
	value &= ~masks[bitnumber]


To avoid surprises involving the sign bit, it is often a good idea to use unsigned integral types in code which manipulates bits and bytes. 

See also questions 9.2 and 20.8. 



Q 96: How can I implement sets or arrays of bits? 

A: Use arrays of char or int, with a few macros to access the desired bit in the proper cell of the array. Here are some simple macros to use with arrays of char: 

#include <limits.h>		/* for CHAR_BIT */

#define BITMASK(b) (1 << ((b) % CHAR_BIT))
#define BITSLOT(b) ((b) / CHAR_BIT)
#define BITSET(a, b) ((a)[BITSLOT(b)] |= BITMASK(b))
#define BITCLEAR(a, b) ((a)[BITSLOT(b)] &= ~BITMASK(b))
#define BITTEST(a, b) ((a)[BITSLOT(b)] & BITMASK(b))
#define BITNSLOTS(nb) ((nb + CHAR_BIT - 1) / CHAR_BIT)

(If you don't have <limits.h>, try using 8 for CHAR_BIT.) 

Here are some usage examples. To declare an ``array'' of 47 bits: 

	char bitarray[BITNSLOTS(47)];

To set the 23rd bit: 
	BITSET(bitarray, 23);

To test the 35th bit: 
	if(BITTEST(bitarray, 35)) ...

To compute the union of two bit arrays and place it in a third array (with all three arrays declared as above): 
	for(i = 0; i < BITNSLOTS(47); i++)
		array3[i] = array1[i] | array2[i];

To compute the intersection, use & instead of |. 

As a more realistic example, here is a quick implementation of the Sieve of Eratosthenes, for computing prime numbers: 

#include <stdio.h>
#include <string.h>

#define MAX 10000

int main()
{
	char bitarray[BITNSLOTS(MAX)];
	int i, j;

	memset(bitarray, 0, BITNSLOTS(MAX));

	for(i = 2; i < MAX; i++) {
		if(!BITTEST(bitarray, i)) {
			printf("%d\n", i);
			for(j = i + i; j < MAX; j += i)
				BITSET(bitarray, j);
		}
	}
	return 0;
}




Q 97: How do I swap bytes? 

A: V7 Unix had a swab function, but it seems to have been forgotten. 

A problem with explicit byte-swapping code is that you have to decide whether to call it or not, based on the byte order of the data and the byte order of the machine in use. Question 20.9 shows how, but it's a nuisance. 

A better solution is to define functions which convert between the known byte order of the data and the (unknown) byte order of the machine in use, and to arrange for these functions to be no-ops on those machines which already match the desired byte order. A set of such functions, introduced with the BSD networking code but now in wide use, is ntohs, htons, ntohl, and htonl. These are intended to convert between ``network'' and ``host'' byte orders, for ``short'' or ``long'' integers, where ``network'' order is always big-endian, and where ``short'' integers are always 16 bits and ``long'' integers are 32 bits. (This is not the C definition, of course, but it's compatible with the C definition; see question 1.1.) So if you know that the data you want to convert from or to is big-endian, you can use these functions. (The point is that you always call the functions, making your code much cleaner. Each function either swaps bytes if it has to, or does nothing. The decision to swap or not to swap gets made once, when the functions are implemented for a particular machine, rather than being made many times in many different calling programs.) 

If you do have to write your own byte-swapping code, the two obvious approaches are again to use pointers or unions, as in question 20.9. Here is an example using pointers: 

void byteswap(char *ptr, int nwords)
{
	char *p = ptr;
	while(nwords-- > 0) {
		char tmp = *p;
		*p = *(p + 1);
		*(p + 1) = tmp;
		p += 2;
	}
}


And here is one using unions: 

union word
	{
	short int word;
	char halves[2];
	};

void byteswap(char *ptr, int nwords)
{
	register union word *wp = (union word *)ptr;
	while(nwords-- > 0) {
		char tmp = wp->halves[0];
		wp->halves[0] = wp->halves[1];
		wp->halves[1] = tmp;
		wp++;
	}
}


These functions swap two-byte quantities; the extension to four or more bytes should be obvious. The union-using code is imperfect in that it assumes that the passed-in pointer is word-aligned. It would also be possible to write functions accepting separate source and destination pointers, or accepting single words and returning the swapped values. 



Q 98: How can I convert integers to binary or hexadecimal? 

A: Make sure you really know what you're asking. Integers are stored internally in binary, although for most purposes it is not incorrect to think of them as being in octal, decimal, or hexadecimal, whichever is convenient. The base in which a number is expressed matters only when that number is read in from or written out to the outside world, either in the form of a source code constant or in the form of I/O performed by a program. 

In source code, a non-decimal base is indicated by a leading 0 or 0x (for octal or hexadecimal, respectively). During I/O, the base of a formatted number is controlled in the printf and scanf family of functions by the choice of format specifier (%d, %o, %x, etc.) and in the strtol and strtoul functions by the third argument. During binary I/O, however, the base again becomes immaterial: if numbers are being read or written as individual bytes (typically with getc or putc), or as multi-byte words (typically with fread or fwrite), it is meaningless to ask what ``base'' they are in. 

If what you need is formatted binary conversion, it's easy enough to do. Here is a little function for formatting a number in a requested base: 

char *
baseconv(unsigned int num, int base)
{
	static char retbuf[33];
	char *p;

	if(base < 2 || base > 16)
		return NULL;

	p = &retbuf[sizeof(retbuf)-1];
	*p = '\0';

	do {
		*--p = "0123456789abcdef"[num % base];
		num /= base;
	} while(num != 0);

	return p;
}

(Note that this function, as written, returns a pointer to static data, such that only one of its return values can be used at a time; see question 7.5a. A better size for the retbuf array would be sizeof(int)*CHAR_BIT+1; see question 12.21.) 

For more information about ``binary'' I/O, see questions 2.11, 12.37, and 12.42. See also questions 8.6 and 13.1. 

Additional links: A long reply I sent to someone who was asking how to write a ``binary to decimal'' conversion function 


Q 99 : Can I use base-2 constants (something like 0b101010)? 
Is there a printf format for binary? 

A: No, on both counts, although there are various preprocessor tricks you can try (see the links below). You can convert base-2 string representations to integers with strtol. If you need to print numbers out in base 2, see the example code in question 20.10. 





Q 100: What is the most efficient way to count the number of bits which are set in an integer? 

A: Many ``bit-fiddling'' problems like this one can be sped up and streamlined using lookup tables (but see question 20.13). Here is a little function which computes the number of bits in a value, 4 bits at a time: 

static int bitcounts[] =
	{0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};

int bitcount(unsigned int u)
{
	int n = 0;

	for(; u != 0; u >>= 4)
		n += bitcounts[u & 0x0f];

	return n;
}



Q 101: Are pointers really faster than arrays? How much do function calls slow things down? Is ++i faster than i = i + 1? 

A: Precise answers to these and many similar questions depend of course on the processor and compiler in use. If you simply must know, you'll have to time test programs carefully. (Often the differences are so slight that hundreds of thousands of iterations are required even to see them. [footnote] Check the compiler's assembly language output, if available, to see if two purported alternatives aren't compiled identically.) 

For conventional machines, it is usually faster to march through large arrays with pointers rather than array subscripts, but for some processors the reverse is true. (Better compilers should generate good code regardless of which notation you use, though it's arguably easier for a compiler to convert array indices to pointers than vice versa[footnote] .) 

Function calls, though obviously incrementally slower than in-line code, contribute so much to modularity and code clarity that there is rarely good reason to avoid them. (Actually, by reducing bulk, functions can improve performance.) Also, some compilers are able to expand small, critical-path functions in-line, either as an optimization or at the programmer's request. 

Before rearranging expressions such as i = i + 1, remember that you are dealing with a compiler, not a keystroke-programmable calculator. Any decent compiler will generate identical code for ++i, i += 1, and i = i + 1. The reasons for using ++i or i += 1 over i = i + 1 have to do with style, not efficiency. (See also question 3.12b.) 



Q 101 : Is there a way to switch on strings? 

A: Not directly. Sometimes, it's appropriate to use a separate function to map strings to integer codes, and then switch on those: 

#define CODE_APPLE	1
#define CODE_ORANGE	2
#define CODE_NONE	0

switch(classifyfunc(string)) {
	case CODE_APPLE:
		...

	case CODE_ORANGE:
		...

	case CODE_NONE:
		...
}

where classifyfunc looks something like 
static struct lookuptab {
	char *string;
	int code;
} tab[] = {
	{"apple",	CODE_APPLE},
	{"orange",	CODE_ORANGE},
};

classifyfunc(char *string)
{
	int i;
	for(i = 0; i < sizeof(tab) / sizeof(tab[0]); i++)
		if(strcmp(tab[i].string, string) == 0)
			return tab[i].code;

	return CODE_NONE;
}


Otherwise, of course, you can fall back on a conventional if/else chain: 

	if(strcmp(string, "apple") == 0) {
		...
	} else if(strcmp(string, "orange") == 0) {
		...
	}

(A macro like Streq() from question 17.3 can make these comparisons a bit more convenient.) 



Q 102: Is there a way to have non-constant case labels (i.e. ranges or arbitrary expressions)? 

A: No. The switch statement was originally designed to be quite simple for the compiler to translate, therefore case labels are limited to single, constant, integral expressions. You can attach several case labels to the same statement, which will let you cover a small range if you don't mind listing all cases explicitly. 

If you want to select on arbitrary ranges or non-constant expressions, you'll have to use an if/else chain. 



Q 103: What is assert() and when would I use it? 

A: It is a macro, defined in <assert.h>, for testing ``assertions''. An assertion essentially documents an assumption being made by the programmer, an assumption which, if violated, would indicate a serious programming error. For example, a function which was supposed to be called with a non-null pointer could write 

	assert(p != NULL);

A failed assertion terminates the program. Assertions should not be used to catch expected errors, such as malloc or fopen failures. 




Q 104: How can I call FORTRAN (C++, BASIC, Pascal, Ada, LISP) functions from C? (And vice versa?) 

A: The answer is entirely dependent on the machine and the specific calling sequences of the various compilers in use, and may not be possible at all. Read your compiler documentation very carefully; sometimes there is a ``mixed-language programming guide,'' although the techniques for passing arguments and ensuring correct run-time startup are often arcane. Besides arranging calling sequences correctly, you may also have to conspire between the various languages to get aggregate data structures declared compatibly. 

For FORTRAN, more information may be found in FORT.gz by Glenn Geers, available via anonymous ftp from suphys.physics.su.oz.au in the src directory. Burkhard Burow's header file cfortran.h simplifies C/FORTRAN interfacing on many popular machines. It is available via anonymous ftp from zebra.desy.de or at http://www-zeus.desy.de/~burow. 

In C++, a "C" modifier in an external function declaration indicates that the function is to be called using C calling conventions. 

In Ada, you can use the Export and Convention pragmas, and types from the package Interfaces.C, to arrange for C-compatible calls, parameters, and data structures. 



Q 105: Is C++ a superset of C? What are the differences between C and C++? Can I use a C++ compiler to compile C code? 

A: C++ was derived from C, and is largely based on it, but there are some legal C constructs which are not legal C++. Conversely, ANSI C inherited several features from C++, including prototypes and const, so neither language is really a subset or superset of the other; the two also define the meaning of some common constructs differently. 

The most important feature of C++ not found in C is of course the extended structure known as a class which along with operator overloading makes object-oriented programming convenient. There are several other differences and new features: variables may be declared anywhere in a block; const variables may be true compile-time constants; structure tags are implicitly typedeffed; an & in a parameter declaration requests pass by reference; and the new and delete operators, along with per-object constructors and destructors, simplify dynamic data structure management. There are a host of mechanisms tied up with classes and object-oriented programming: inheritance, friends, virtual functions, templates, etc. (This list of C++ features is not intended to be complete; C++ programmers will notice many omissions.) 

Some features of C which keep it from being a strict subset of C++ (that is, which keep C programs from necessarily being acceptable to C++ compilers) are that main may be called recursively, character constants are of type int, prototypes are not required, and void * implicitly converts to other pointer types. Also, every keyword in C++ which is not a keyword in C is available in C as an identifier; C programs which use words like class and friend as ordinary identifiers will be rejected by C++ compilers. 

In spite of the differences, many C programs will compile correctly in a C++ environment, and many recent compilers offer both C and C++ compilation modes. (But it's usually a bad idea to compile straight C code as if it were C++; the languages are different enough that you'll generally get poor results.) 



Q 106: How can I find the day of the week given the date? 

A: Here are three methods: 

Use mktime or localtime (see question 13.13). Here is a code fragment which computes the day of the week for February 29, 2000: 
#include <stdio.h>
#include <time.h>

char *wday[] = {"Sunday", "Monday", "Tuesday", "Wednesday",
		"Thursday", "Friday", "Saturday"};

struct tm tm;

tm.tm_mon = 2 - 1;
tm.tm_mday = 29;
tm.tm_year = 2000 - 1900;
tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
tm.tm_isdst = -1;

if(mktime(&tm) != -1)
	printf("%s\n", wday[tm.tm_wday]);

When using mktime like this, it's usually important to set tm_isdst to -1, as shown (especially if tm_hour is 0), otherwise a daylight saving time correction could push the time past midnight into another day. 
Use Zeller's congruence, which says that if 


	J is the number of the century [i.e. the year / 100],
	K the year within the century [i.e. the year % 100],
	m the month,
	q the day of the month,
	h the day of the week [where 1 is Sunday];



and if January and February are taken as months 13 and 14 of the previous year [affecting both J and K]; then h for the Gregorian calendar is the remainder when the sum 


	q + 26(m + 1) / 10 + K + K/4 + J/4 - 2J



is divided by 7, and where all intermediate remainders are discarded. [footnote] The translation into C is straightforward: 
	h = (q + 26 * (m + 1) / 10 + K + K/4 + J/4 + 5*J) % 7;

(where we use +5*J instead of -2*J to make sure that both operands of the modulus operator % are positive; this bias totalling 7*J will obviously not change the final value of h, modulo 7). 
Use this elegant code by Tomohiko Sakamoto: 
int dayofweek(int y, int m, int d)	/* 0 = Sunday */
{
	static int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
	y -= m < 3;
	return (y + y/4 - y/100 + y/400 + t[m-1] + d) % 7;
}


Q 107: Here's a good puzzle: how do you write a program which produces its own source code as output? 

A: It is actually quite difficult to write a self-reproducing program that is truly portable, due particularly to quoting and character set difficulties. 

Here is a classic example (which ought to be presented on one line, although it will fix itself the first time it's run): 

char*s="char*s=%c%s%c;main(){printf(s,34,s,34);}";
main(){printf(s,34,s,34);}

(This program has a few deficiencies, among other things neglecting to #include <stdio.h>, and assuming that the double-quote character " has the value 34, as it does in ASCII.) 

Here is an improved version, posted by James Hu: 

#define q(k)main(){return!puts(#k"\nq("#k")");}
q(#define q(k)main(){return!puts(#k"\nq("#k")");})





Q 108: What is ``Duff's Device''? 

A: It's a devastatingly devious way of unrolling a loop, devised by Tom Duff while he was at Lucasfilm. In its ``classic'' form, it was used to copy bytes, and looked like this: 

	register n = (count + 7) / 8;	/* count > 0 assumed */
	switch (count % 8)
	{
	case 0:	   do { *to = *from++;
	case 7:		*to = *from++;
	case 6:		*to = *from++;
	case 5:		*to = *from++;
	case 4:		*to = *from++;
	case 3:		*to = *from++;
	case 2:		*to = *from++;
	case 1:		*to = *from++;
		      } while (--n > 0);
	}

where count bytes are to be copied from the array pointed to by from to the memory location pointed to by to (which is a memory-mapped device output register, which is why to isn't incremented). It solves the problem of handling the leftover bytes (when count isn't a multiple of 8) by interleaving a switch statement with the loop which copies bytes 8 at a time. (Believe it or not, it is legal to have case labels buried within blocks nested in a switch statement like this. In his announcement of the technique to C's developers and the world, Duff noted that C's switch syntax, in particular its ``fall through'' behavior, had long been controversial, and that ``This code forms some sort of argument in that debate, but I'm not sure whether it's for or against.'') 



Q 109: Where does the name ``C'' come from, anyway? 

A: C was derived from Ken Thompson's experimental language B, which was inspired by Martin Richards's BCPL (Basic Combined Programming Language), which was a simplification of CPL (Combined Programming Language, or perhaps Cambridge Programming Language). For a while, there was speculation that C's successor might be named P (the third letter in BCPL) instead of D, but of course the most visible descendant language today is C++. 

References: Dennis Ritchie, ``The Development of the C Language'' 


Q 110: What do ``lvalue'' and ``rvalue'' mean? 

A: Simply speaking, an lvalue is an expression that could appear on the left-hand sign of an assignment; you can also think of it as denoting an object that has a location. (But see question 6.7 concerning arrays.) An rvalue is any expression that has a value (and that can therefore appear on the right-hand sign of an assignment). 

