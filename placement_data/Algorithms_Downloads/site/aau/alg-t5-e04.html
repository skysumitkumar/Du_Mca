<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Algorithms and Data Structures, Aalborg University
  (INF1, Autumn'04)</title>
</head>
<body bgcolor="white">
 <h3>Algorithms and Data Structures (INF1, Autumn'04)</h3>
 <h2>Exercise Set 5</h2>
<br>
<b>Exercise 1:</b> <br><br>

In this exercise you are asked to implement the operation <b>merge</b> from the 
D&C sorting algorithm explained at the lecture. <br><br>

Let A[1..n], B[1..m] and C[1..(n+m)] be arrays such that n,m>0.

<UL>
<li>
Write an algorithm merge(A,B) which will return an array of
size n+m  and satisfy the following conditions. 
Try to achieve an optimal time complexity.
<br><br>

--pre: A and B are non-decreasing arrays <br><br>

C:=merge(A,B); <br><br>

--post: C is a non-decreasing array and it is a permutation of
        the elements from A and B <br><br>

<li> Run your algorithm on the following instance of the problem:
A = [3,4,7] and B =[1,4,8] (i.e.  A[1]=3, A[2]=4, A[3]=7, B[1]=1, B[2]=4,
 B[3]=8).
<br><br>
<li> What is the worst-case time complexity of your algorithm (use the
     big-O notation and justify your answer)?
</UL>

<br> <br> <br>

<b>Exercise 2 (hand in):</b> <br><br>

Recall the ADT called SET from the lecture. For a set s:SET
we have the following basic operations 
<UL>
<LI> s.make
<LI> s.empty:boolean
<LI> s.insert(x:int)
<LI> s.delete_any:int
</UL>
and we also defined a non-destructive version of member(x:int,s:SET):boolean.
<br><br>

Define a new set operation <b>sum(s:SET):int</b> satisfying <br><br>
--pre: s is a SET <br>
x:=sum(s)<br>
--post: x=&Sigma;<SUB>a &isin; S</SUB> a 
&nbsp;
&nbsp;
and 
&nbsp;
s'=s
<br><br>
Assume now that <em>somebody gave you a better implementation of
SET than what we did at the lecture</em>. However, the only info you know
about the new implementation is that 
<UL>
<LI>
all the basic set operations (make, empty, insert, and delete) 
and the operation member satisfy exactly the same pre- and post- 
conditions as before 
<LI>
if we assume that the number of elements in the set s is n 
then (in the worst-case)
<UL>
<li> s.make takes O(1) time 
<li> s.empty takes O(1) time 
<li> s.insert takes O(1) time 
<li> s.delete_any takes O(1) time
<li> member(x,s) takes O(n) time.
 </UL>
</UL>

Is this piece of information
enough to analyze the worst-case time complexity of your sum operation?
<UL>
<LI> If yes, provide the worst-case time complexity of sum(s) where the size
of your input is the number of elements in s (let's call this number n).
</UL>
<br><br>
 
<b>Exercise 3:</b><br><br>

Assume the same "better" implementation of SET as in Example 2. <br><br>
Define a new operation <b>intersection(s<sub>1</sub>:SET,
 s<sub>2</sub>:SET):SET</b>
satisfying <br><br>

--pre: s<sub>1</sub> and s<sub>2</sub> are SETs <br><br>

s:=intersection(s<sub>1</sub>, s<sub>2</sub>) <br><br>

--post: s = s<sub>1</sub> &cap; s<sub>2</sub> &nbsp; and &nbsp; 
s'<sub>1</sub> = s<sub>1</sub> &nbsp; and &nbsp;  
s'<sub>2</sub> =  s<sub>2</sub>
<br><br>
Provide the worst-case time complexity analysis of 
intersection(s<sub>1</sub>, s<sub>2</sub>) (use
|s<sub>1</sub>| for the number of elements in the set
s<sub>1</sub> and |s<sub>2</sub>| for the number of elements
in s<sub>2</sub>).
</body>
</html>


